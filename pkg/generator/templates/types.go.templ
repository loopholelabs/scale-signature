// Code generated by scale-signature-go {{ .version }}, DO NOT EDIT.
// schema: {{ .schema.Name }}:{{ .schema.Tag }}
// output: types.go

package {{ .package }}

import (
    "github.com/loopholelabs/polyglot-go"
    "errors"
)

var (
	NilDecode = errors.New("cannot decode into a nil root struct")
	InvalidEnum = errors.New("invalid enum value")
)

{{- range .schema.Models -}}
{{ $current_model := . }}

{{- range .Enums }}
type Enum{{ $current_model.Name }}{{ .Name }} uint32
{{ $current_enum := . }}
const (
    {{- range $index, $value := .Values }}
    Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }} Enum{{ $current_model.Name }}{{ $current_enum.Name }} = {{ $index }}
    {{ end }}
)
{{ end }}

{{- range .EnumArrays }}
type Enum{{ $current_model.Name }}{{ .Name }} uint32
{{ $current_enum := . }}
const (
    {{- range $index, $value := .Values }}
    Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }} Enum{{ $current_model.Name }}{{ $current_enum.Name }} = {{ $index }}
    {{ end }}
)
{{ end }}

{{- range .EnumMaps }}
type Enum{{ $current_model.Name }}{{ .Name }} uint32
{{ $current_enum := . }}
const (
    {{- range $index, $value := .Values }}
    Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }} Enum{{ $current_model.Name }}{{ $current_enum.Name }} = {{ $index }}
    {{ end }}
)
{{ end }}

{{- if .Description }}
// {{ .Name }}: {{ .Description }}
{{ end -}}

type {{ .Name }} struct {

{{- range .Models }}
    {{- if .Accessor }}
    {{ LowerFirst .Name }} *{{ .Reference }}
    {{- else }}
    {{ .Name }} *{{ .Reference }}
    {{- end -}}
{{ end }}

{{- range .ModelArrays }}
    {{- if .Accessor }}
    {{ LowerFirst .Name }} []*{{ .Reference }}
    {{- else }}
    {{ .Name }} []*{{ .Reference }}
    {{- end -}}
{{ end }}

{{- range .ModelMaps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[*{{ .Reference }}]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[*{{ .Reference }}]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[*{{ .Reference }}]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[*{{ .Reference }}]*{{ .Value }}
    {{- end }}
{{ end }}

{{- range .Strings }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} string
    {{- else }}
    {{ .Name }} string
    {{- end -}}
{{ end }}

{{- range .StringArrays }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} []string
    {{- else }}
    {{ .Name }} []string
    {{- end -}}
{{ end }}

{{- range .StringMaps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[string]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[string]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[string]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[string]*{{ .Value }}
    {{- end }}
{{ end }}

{{- range .Int32s }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} int32
    {{- else }}
    {{ .Name }} int32
    {{- end -}}
{{ end }}

{{- range .Int32Arrays }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} []int32
    {{- else }}
    {{ .Name }} []int32
    {{- end -}}
{{ end }}

{{- range .Int32Maps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[int32]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[int32]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[int32]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[int32]*{{ .Value }}
    {{- end }}
{{ end }}

{{- range .Int64s }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} int64
    {{- else }}
    {{ .Name }} int64
    {{- end -}}
{{ end }}

{{- range .Int64Arrays }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} []int64
    {{- else }}
    {{ .Name }} []int64
    {{- end -}}
{{ end }}

{{- range .Int64Maps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[int64]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[int64]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[int64]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[int64]*{{ .Value }}
    {{- end }}
{{ end }}

{{- range .Uint32s }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} uint32
    {{- else }}
    {{ .Name }} uint32
    {{- end -}}
{{ end }}

{{- range .Uint32Arrays }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} []uint32
    {{- else }}
    {{ .Name }} []uint32
    {{- end -}}
{{ end }}

{{- range .Uint32Maps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[uint32]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[uint32]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[uint32]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[uint32]*{{ .Value }}
    {{- end }}
{{ end }}

{{- range .Uint64s }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} uint64
    {{- else }}
    {{ .Name }} uint64
    {{- end -}}
{{ end }}

{{- range .Uint64Arrays }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} []uint64
    {{- else }}
    {{ .Name }} []uint64
    {{- end -}}
{{ end }}

{{- range .Uint64Maps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[uint64]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[uint64]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[uint64]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[uint64]*{{ .Value }}
    {{- end }}
{{ end }}

{{- range .Float32s }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} float32
    {{- else }}
    {{ .Name }} float32
    {{- end -}}
{{ end }}

{{- range .Float32Arrays }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} []float32
    {{- else }}
    {{ .Name }} []float32
    {{- end -}}
{{ end }}

{{- range .Float32Maps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[float32]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[float32]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[float32]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[float32]*{{ .Value }}
    {{- end }}
{{ end }}

{{- range .Float64s }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} float64
    {{- else }}
    {{ .Name }} float64
    {{- end -}}
{{ end }}

{{- range .Float64Arrays }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} []float64
    {{- else }}
    {{ .Name }} []float64
    {{- end -}}
{{ end }}

{{- range .Float64Maps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[float64]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[float64]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[float64]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[float64]*{{ .Value }}
    {{- end }}
{{ end }}

{{- range .Bytes }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} []byte
    {{- else }}
    {{ .Name }} []byte
    {{- end -}}
{{ end }}

{{- range .BytesArrays }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} [][]byte
    {{- else }}
    {{ .Name }} [][]byte
    {{- end -}}
{{ end }}

{{- range .BytesMaps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[[]byte]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[[]byte]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[[]byte]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[[]byte]*{{ .Value }}
    {{- end }}
{{ end }}

{{- range .Enums }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} Enum{{ $current_model.Name }}{{ .Name }}
    {{- else }}
    {{ .Name }} Enum{{ $current_model.Name }}{{ .Name }}
    {{- end -}}
{{ end }}

{{- range .EnumArrays }}
    {{- if (Deref .Accessor) }}
    {{ LowerFirst .Name }} []Enum{{ $current_model.Name }}{{ .Name }}
    {{- else }}
    {{ .Name }} []Enum{{ $current_model.Name }}{{ .Name }}
    {{- end -}}
{{ end }}

{{- range .EnumMaps }}
    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    {{ LowerFirst .Name }} map[Enum{{ $current_model.Name }}{{ .Name }}]{{ Primitive .Value }}
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    {{ LowerFirst .Name }} map[Enum{{ $current_model.Name }}{{ .Name }}]*{{ .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    {{ .Name }} map[Enum{{ $current_model.Name }}{{ .Name }}]{{ Primitive .Value }}
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    {{ .Name }} map[Enum{{ $current_model.Name }}{{ .Name }}]*{{ .Value }}
    {{- end }}
{{ end }}
}

func New{{ .Name }}() *{{ .Name }} {
    return &{{ .Name }}{
        {{- range .Models }}

        {{- if .Accessor }}
        {{ LowerFirst .Name }}: New{{ .Reference }}(),
        {{- else }}
        {{ .Name }}: New{{ .Reference }}(),
        {{- end -}}

        {{ end }}

        {{- range .ModelArrays }}

        {{- if .Accessor }}
        {{ LowerFirst .Name }}: make([]*{{ .Reference }},  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]*{{ .Reference }}, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .ModelMaps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[*{{ .Reference }}]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[*{{ .Reference }}]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[*{{ .Reference }}]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[*{{ .Reference }}]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .StringArrays }}

        {{- if (Deref .Accessor) }}
        {{ LowerFirst .Name }}: make([]string,  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]string, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .StringMaps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[string]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[string]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[string]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[string]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .Int32Arrays }}

        {{- if (Deref .Accessor) }}
        {{ LowerFirst .Name }}: make([]int32,  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]int32, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .Int32Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[int32]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[int32]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[int32]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[int32]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .Int64Arrays }}

        {{- if (Deref .Accessor) }}
        {{ LowerFirst .Name }}: make([]int64,  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]int64, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .Int64Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[int64]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[int64]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[int64]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[int64]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .Uint32Arrays }}

        {{- if (Deref .Accessor) }}
        {{ LowerFirst .Name }}: make([]uint32,  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]uint32, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .Uint32Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[uint32]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[uint32]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[uint32]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[uint32]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .Uint64Arrays }}

        {{- if (Deref .Accessor) }}
        {{ LowerFirst .Name }}: make([]uint64,  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]uint64, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .Uint64Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[uint64]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[uint64]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[uint64]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[uint64]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .Float32Arrays }}

        {{- if (Deref .Accessor) }}
        {{ LowerFirst .Name }}: make([]float32,  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]float32, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .Float32Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[float32]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[float32]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[float32]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[float32]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .Float64Arrays }}

        {{- if (Deref .Accessor) }}
        {{ LowerFirst .Name }}: make([]float64,  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]float64, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .Float64Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[float64]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[float64]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[float64]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[float64]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .EnumArrays }}

        {{- if .Accessor }}
        {{ LowerFirst .Name }}: make([]Enum{{ $current_model.Name }}{{ .Name }},  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]Enum{{ $current_model.Name }}{{ .Name }}, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .EnumMaps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[Enum{{ $current_model.Name }}{{ .Name }}]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[Enum{{ $current_model.Name }}{{ .Name }}]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[Enum{{ $current_model.Name }}{{ .Name }}]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[Enum{{ $current_model.Name }}{{ .Name }}]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .BytesArrays }}

        {{- if .Accessor }}
        {{ LowerFirst .Name }}: make([][]byte,  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([][]byte, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}

        {{- range .BytesMaps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        {{ LowerFirst .Name }}: make(map[[]byte]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        {{ LowerFirst .Name }}: make(map[[]byte]*{{ .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        {{ .Name }}: make(map[[]byte]{{ Primitive .Value }}),
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        {{ .Name }}: make(map[[]byte]*{{ .Value }}),
        {{- end }}

        {{ end }}

        {{- range .BoolArrays }}

        {{- if .Accessor }}
        {{ LowerFirst .Name }}: make([]bool,  {{.InitialSize }}),
        {{- else }}
        {{ .Name }}: make([]bool, {{ .InitialSize }}),
        {{- end -}}

        {{ end }}
    }
}

func (x *{{ .Name }}) encode(b *polyglot.Buffer) {
    e := polyglot.Encoder(b)
    if x == nil {
        e.Nil()
    } else {
        {{- range .Models }}

        x.{{ .Name }}.encode(b)

        {{ end }}

        {{- range .ModelArrays }}

        e.Slice(uint32(len(x.{{ .Name }})), polyglot.AnyKind)
        for _, a := range x.{{ .Name }} {
            a.encode(b)
        }

        {{ end }}

        {{- range .ModelMaps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.AnyKind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
            k.encode(b)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.AnyKind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
            k.encode(b)
            v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.AnyKind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
            k.encode(b)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.AnyKind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
            k.encode(b)
            v.encode(b)
        }
        {{- end }}

        {{ end }}

        {{- range .Strings }}

        {{- if (Deref .Accessor) }}
        e.String(x.{{ LowerFirst .Name }})
        {{- else }}
        e.String(x.{{ .Name }})
        {{- end -}}

        {{ end }}

        {{- range .StringArrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.StringKind)
        for _, a := range x.{{ LowerFirst .Name }} {
            e.String(a)
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.StringKind)
        for _, a := range x.{{ .Name }} {
            e.String(a)
        }
        {{- end -}}

        {{ end }}

        {{- range .StringMaps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.StringKind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
            e.String(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.StringKind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
            e.String(k)
            v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.StringKind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
            e.String(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.StringKind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
            e.String(k)
            v.encode(b)
        }
        {{- end }}

        {{ end }}

        {{- range .Bools }}

        {{- if (Deref .Accessor) }}
        e.Bool(x.{{ LowerFirst .Name }})
        {{- else }}
        e.Bool(x.{{ .Name }})
        {{- end -}}

        {{ end }}

        {{- range .BoolArrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.BoolKind)
        for _, a := range x.{{ LowerFirst .Name }} {
            e.Bool(a)
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.BoolKind)
        for _, a := range x.{{ .Name }} {
            e.Bool(a)
        }
        {{- end -}}

        {{ end }}

        {{- range .Bytes }}

        {{- if (Deref .Accessor) }}
        e.Bytes(x.{{ LowerFirst .Name }})
        {{- else }}
        e.Bytes(x.{{ .Name }})
        {{- end -}}

        {{ end }}

        {{- range .BytesArrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.BytesKind)
        for _, a := range x.{{ LowerFirst .Name }} {
           e.Bytes(a)
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.BytesKind)
        for _, a := range x.{{ .Name }} {
           e.Bytes(a)
        }
        {{- end -}}

        {{ end }}

        {{- range .BytesMaps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.BytesKind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
           e.Bytes(k)
           e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.BytesKind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
           e.Bytes(k)
           v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.BytesKind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
           e.Bytes(k)
           e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.BytesKind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
           e.Bytes(k)
           v.encode(b)
        }
        {{- end }}

        {{ end }}

        {{- range .Enums }}

        {{- if (Deref .Accessor) }}
        e.Uint32(uint32(x.{{ LowerFirst .Name }}))
        {{- else }}
        e.Uint32(uint32(x.{{ .Name }}))
        {{- end -}}

        {{ end }}

        {{- range .EnumArrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Uint32Kind)
        for _, a := range x.{{ LowerFirst .Name }} {
           e.Uint32(uint32(a))
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.Uint32Kind)
        for _, a := range x.{{ .Name }} {
           e.Uint32(uint32(a))
        }
        {{- end -}}

        {{ end }}

        {{- range .EnumMaps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Uint32Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
           e.Uint32(uint32(k))
           e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Uint32Kind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
           e.Uint32(uint32(k))
           v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Uint32Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
           e.Uint32(uint32(k))
           e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Uint32Kind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
           e.Uint32(uint32(k))
           v.encode(b)
        }
        {{- end }}

        {{ end }}

        {{- range .Int32s }}

        {{- if (Deref .Accessor) }}
        e.Int32(x.{{ LowerFirst .Name }})
        {{- else }}
        e.Int32(x.{{ .Name }})
        {{- end -}}

        {{ end }}

        {{- range .Int32Arrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Int32Kind)
        for _, a := range x.{{ LowerFirst .Name }} {
            e.Int32(a)
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.Int32Kind)
        for _, a := range x.{{ .Name }} {
            e.Int32(a)
        }
        {{- end -}}

        {{ end }}

        {{- range .Int32Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Int32Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Int32(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Int32Kind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Int32(k)
            v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Int32Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
            e.Int32(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Int32Kind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
            e.Int32(k)
            v.encode(b)
        }
        {{- end }}

        {{ end }}

        {{- range .Int64s }}

        {{- if (Deref .Accessor) }}
        e.Int64(x.{{ LowerFirst .Name }})
        {{- else }}
        e.Int64(x.{{ .Name }})
        {{- end -}}

        {{ end }}

        {{- range .Int64Arrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Int64Kind)
        for _, a := range x.{{ LowerFirst .Name }} {
            e.Int64(a)
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.Int64Kind)
        for _, a := range x.{{ .Name }} {
            e.Int64(a)
        }
        {{- end -}}

        {{ end }}

        {{- range .Int64Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Int64Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Int64(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Int64Kind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Int64(k)
            v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Int64Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
            e.Int64(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Int64Kind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
            e.Int64(k)
            v.encode(b)
        }
        {{- end }}

        {{ end }}

        {{- range .Uint32s }}

        {{- if (Deref .Accessor) }}
        e.Uint32(x.{{ LowerFirst .Name }})
        {{- else }}
        e.Uint32(x.{{ .Name }})
        {{- end -}}

        {{ end }}

        {{- range .Uint32Arrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Uint32Kind)
        for _, a := range x.{{ LowerFirst .Name }} {
            e.Uint32(a)
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.Uint32Kind)
        for _, a := range x.{{ .Name }} {
            e.Uint32(a)
        }
        {{- end -}}

        {{ end }}

        {{- range .Uint32Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Uint32Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Uint32(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Uint32Kind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Uint32(k)
            v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Uint32Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
            e.Uint32(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Uint32Kind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
            e.Uint32(k)
            v.encode(b)
        }
        {{- end }}

        {{ end }}

        {{- range .Uint64s }}

        {{- if (Deref .Accessor) }}
        e.Uint64(x.{{ LowerFirst .Name }})
        {{- else }}
        e.Uint64(x.{{ .Name }})
        {{- end -}}

        {{ end }}

        {{- range .Uint64Arrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Uint64Kind)
        for _, a := range x.{{ LowerFirst .Name }} {
            e.Uint64(a)
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.Uint64Kind)
        for _, a := range x.{{ .Name }} {
            e.Uint64(a)
        }
        {{- end -}}

        {{ end }}

        {{- range .Uint64Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Uint64Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Uint64(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Uint64Kind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Uint64(k)
            v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Uint64Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
            e.Uint64(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Uint64Kind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
            e.Uint64(k)
            v.encode(b)
        }
        {{- end }}

        {{ end }}

        {{- range .Float32s }}

        {{- if (Deref .Accessor) }}
        e.Float32(x.{{ LowerFirst .Name }})
        {{- else }}
        e.Float32(x.{{ .Name }})
        {{- end -}}

        {{ end }}

        {{- range .Float32Arrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Float32Kind)
        for _, a := range x.{{ LowerFirst .Name }} {
            e.Float32(a)
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.Float32Kind)
        for _, a := range x.{{ .Name }} {
            e.Float32(a)
        }
        {{- end -}}

        {{ end }}

        {{- range .Float32Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Float32Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Float32(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Float32Kind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Float32(k)
            v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Float32Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
            e.Float32(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Float32Kind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
            e.Float32(k)
            v.encode(b)
        }
        {{- end }}

        {{ end }}

        {{- range .Float64s }}

        {{- if (Deref .Accessor) }}
        e.Float64(x.{{ LowerFirst .Name }})
        {{- else }}
        e.Float64(x.{{ .Name }})
        {{- end -}}

        {{ end }}

        {{- range .Float64Arrays }}

        {{- if (Deref .Accessor) }}
        e.Slice(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Float64Kind)
        for _, a := range x.{{ LowerFirst .Name }} {
            e.Float64(a)
        }
        {{- else }}
        e.Slice(uint32(len(x.{{ .Name }})), polyglot.Float64Kind)
        for _, a := range x.{{ .Name }} {
            e.Float64(a)
        }
        {{- end -}}

        {{ end }}

        {{- range .Float64Maps }}

        {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Float64Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Float64(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ LowerFirst .Name }})), polyglot.Float64Kind, polyglot.AnyKind)
        for k, v := range x.{{ LowerFirst .Name }} {
            e.Float64(k)
            v.encode(b)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Float64Kind, {{ PolyglotPrimitive .Value }})
        for k, v := range x.{{ .Name }} {
            e.Float64(k)
            e.{{ PolyglotPrimitiveEncode .Value }}(v)
        }
        {{- end }}

        {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
        e.Map(uint32(len(x.{{ .Name }})), polyglot.Float64Kind, polyglot.AnyKind)
        for k, v := range x.{{ .Name }} {
            e.Float64(k)
            v.encode(b)
        }
        {{- end }}

        {{ end }}
    }
}

func (x *{{ .Name }}) decode(b []byte) error {
    if x == nil {
        return NilDecode
    }
    d := polyglot.GetDecoder(b)
    defer d.Return()
    return x._decode(d)
}

func (x *{{ .Name }}) _decode(d *polyglot.Decoder) error {
    if d.Nil() {
		return nil
	}

	err, _ := d.Error()
    if err != nil {
        return err
    }

    {{- range .Models }}

    if x.{{ .Name }} == nil {
        x.{{ .Name }} = New{{ .Reference }}()
    }

    err = x.{{ .Name }}._decode(d)
	if err != nil {
		return err
	}

    {{ end }}

    {{- range .ModelArrays }}
	sliceSize{{ .Name }}, err := d.Slice(polyglot.AnyKind)
	if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([]*{{ .Reference }}, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        x.{{ .Name }}[i] = New{{ .Reference }}()
        err = x.{{ .Name }}[i]._decode(d)
        if err != nil {
            return err
        }
    }

    {{ end }}

    {{- range .ModelMaps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.AnyKind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[*{{ .Reference }}]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k := New{{ .Reference }}()
        err = k._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.AnyKind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[*{{ .Reference }}]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k := New{{ .Reference }}()
        err = k._decode(d)
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.AnyKind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[*{{ .Reference }}]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k := New{{ .Reference }}()
        err = k._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.AnyKind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[*{{ .Reference }}]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k := New{{ .Reference }}()
        err = k._decode(d)
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    {{- range .Strings }}

    {{- if (Deref .Accessor) }}
    x.{{ LowerFirst .Name }}, err = d.String()
    if err != nil {
        return err
    }
    {{- else }}
    x.{{ .Name }}, err = d.String()
    if err != nil {
        return err
    }
    {{- end -}}

    {{ end }}

    {{- range .StringArrays }}

    {{- if (Deref .Accessor) }}
    sliceSize{{ LowerFirst .Name }}, err := d.Slice(polyglot.StringKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != sliceSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make([]string, sliceSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < sliceSize{{ LowerFirst .Name }}; i++ {
        x.{{ LowerFirst .Name }}[i], err = d.String()
        if err != nil {
            return err
        }
    }
    {{- else }}
    sliceSize{{ .Name }}, err := d.Slice(polyglot.StringKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([]string, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        x.{{ .Name }}[i], err = d.String()
        if err != nil {
            return err
        }
    }
    {{- end -}}

    {{ end }}

    {{- range .StringMaps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.StringKind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[string]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.String()
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.StringKind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[string]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.String()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.StringKind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[string]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.String()
        if err != nil {
            return err
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.StringKind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[string]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.String()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    {{- range .Int32s }}

    {{- if (Deref .Accessor) }}
    x.{{ LowerFirst .Name }}, err = d.Int32()
    if err != nil {
        return err
    }
    {{- else }}
    x.{{ .Name }}, err = d.Int32()
    if err != nil {
        return err
    }
    {{- end -}}

    {{ end }}

    {{- range .Int32Arrays }}

    {{- if (Deref .Accessor) }}
    sliceSize{{ LowerFirst .Name }}, err := d.Slice(polyglot.Int32Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != sliceSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make([]int32, sliceSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < sliceSize{{ LowerFirst .Name }}; i++ {
        x.{{ LowerFirst .Name }}[i], err = d.Int32()
        if err != nil {
            return err
        }
    }
    {{- else }}
    sliceSize{{ .Name }}, err := d.Slice(polyglot.Int32Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([]int32, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        x.{{ .Name }}[i], err = d.Int32()
        if err != nil {
            return err
        }
    }
    {{- end -}}

    {{ end }}

    {{- range .Int32Maps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Int32Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[int32]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Int32()
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Int32Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[int32]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Int32()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Int32Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[int32]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Int32()
        if err != nil {
            return err
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Int32Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[int32]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Int32()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    {{- range .Int64s }}

    {{- if (Deref .Accessor) }}
    x.{{ LowerFirst .Name }}, err = d.Int64()
    if err != nil {
        return err
    }
    {{- else }}
    x.{{ .Name }}, err = d.Int64()
    if err != nil {
        return err
    }
    {{- end -}}

    {{ end }}

    {{- range .Int64Arrays }}

    {{- if (Deref .Accessor) }}
    sliceSize{{ LowerFirst .Name }}, err := d.Slice(polyglot.Int64Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != sliceSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make([]int64, sliceSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < sliceSize{{ LowerFirst .Name }}; i++ {
        x.{{ LowerFirst .Name }}[i], err = d.Int64()
        if err != nil {
            return err
        }
    }
    {{- else }}
    sliceSize{{ .Name }}, err := d.Slice(polyglot.Int64Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([]int64, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        x.{{ .Name }}[i], err = d.Int64()
        if err != nil {
            return err
        }
    }
    {{- end -}}

    {{ end }}

    {{- range .Int64Maps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Int64Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[int64]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Int64()
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Int64Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[int64]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Int64()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Int64Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[int64]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Int64()
        if err != nil {
            return err
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Int64Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[int64]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Int64()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    {{- range .Uint32s }}

    {{- if (Deref .Accessor) }}
    x.{{ LowerFirst .Name }}, err = d.Uint32()
    if err != nil {
        return err
    }
    {{- else }}
    x.{{ .Name }}, err = d.Uint32()
    if err != nil {
        return err
    }
    {{- end -}}

    {{ end }}

    {{- range .Uint32Arrays }}

    {{- if (Deref .Accessor) }}
    sliceSize{{ LowerFirst .Name }}, err := d.Slice(polyglot.Uint32Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != sliceSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make([]uint32, sliceSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < sliceSize{{ LowerFirst .Name }}; i++ {
        x.{{ LowerFirst .Name }}[i], err = d.Uint32()
        if err != nil {
            return err
        }
    }
    {{- else }}
    sliceSize{{ .Name }}, err := d.Slice(polyglot.Uint32Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([]uint32, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        x.{{ .Name }}[i], err = d.Uint32()
        if err != nil {
            return err
        }
    }
    {{- end -}}

    {{ end }}

    {{- range .Uint32Maps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Uint32Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[uint32]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Uint32()
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[uint32]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Uint32()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Uint32Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[uint32]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Uint32()
        if err != nil {
            return err
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[uint32]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Uint32()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    {{- range .Uint64s }}

    {{- if (Deref .Accessor) }}
    x.{{ LowerFirst .Name }}, err = d.Uint64()
    if err != nil {
        return err
    }
    {{- else }}
    x.{{ .Name }}, err = d.Uint64()
    if err != nil {
        return err
    }
    {{- end -}}

    {{ end }}

    {{- range .Uint64Arrays }}

    {{- if (Deref .Accessor) }}
    sliceSize{{ LowerFirst .Name }}, err := d.Slice(polyglot.Uint64Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != sliceSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make([]uint64, sliceSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < sliceSize{{ LowerFirst .Name }}; i++ {
        x.{{ LowerFirst .Name }}[i], err = d.Uint64()
        if err != nil {
            return err
        }
    }
    {{- else }}
    sliceSize{{ .Name }}, err := d.Slice(polyglot.Uint64Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([]uint64, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        x.{{ .Name }}[i], err = d.Uint64()
        if err != nil {
            return err
        }
    }
    {{- end -}}

    {{ end }}

    {{- range .Uint64Maps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Uint64Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[uint64]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Uint64()
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Uint64Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[uint64]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Uint64()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Uint64Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[uint64]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Uint64()
        if err != nil {
            return err
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Uint64Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[uint64]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Uint64()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    {{- range .Float32s }}

    {{- if (Deref .Accessor) }}
    x.{{ LowerFirst .Name }}, err = d.Float32()
    if err != nil {
        return err
    }
    {{- else }}
    x.{{ .Name }}, err = d.Float32()
    if err != nil {
        return err
    }
    {{- end -}}

    {{ end }}

    {{- range .Float32Arrays }}

    {{- if (Deref .Accessor) }}
    sliceSize{{ LowerFirst .Name }}, err := d.Slice(polyglot.Float32Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != sliceSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make([]float32, sliceSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < sliceSize{{ LowerFirst .Name }}; i++ {
        x.{{ LowerFirst .Name }}[i], err = d.Float32()
        if err != nil {
            return err
        }
    }
    {{- else }}
    sliceSize{{ .Name }}, err := d.Slice(polyglot.Float32Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([]float32, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        x.{{ .Name }}[i], err = d.Float32()
        if err != nil {
            return err
        }
    }
    {{- end -}}

    {{ end }}

    {{- range .Float32Maps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Float32Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[float32]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Float32()
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Float32Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[float32]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Float32()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Float32Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[float32]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Float32()
        if err != nil {
            return err
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Float32Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[float32]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Float32()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    {{- range .Float64s }}

    {{- if (Deref .Accessor) }}
    x.{{ LowerFirst .Name }}, err = d.Float64()
    if err != nil {
        return err
    }
    {{- else }}
    x.{{ .Name }}, err = d.Float64()
    if err != nil {
        return err
    }
    {{- end -}}

    {{ end }}

    {{- range .Float64Arrays }}

    {{- if (Deref .Accessor) }}
    sliceSize{{ LowerFirst .Name }}, err := d.Slice(polyglot.Float64Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != sliceSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make([]float64, sliceSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < sliceSize{{ LowerFirst .Name }}; i++ {
        x.{{ LowerFirst .Name }}[i], err = d.Float64()
        if err != nil {
            return err
        }
    }
    {{- else }}
    sliceSize{{ .Name }}, err := d.Slice(polyglot.Float64Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([]float64, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        x.{{ .Name }}[i], err = d.Float64()
        if err != nil {
            return err
        }
    }
    {{- end -}}

    {{ end }}

    {{- range .Float64Maps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Float64Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[float64]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Float64()
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Float64Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[float64]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Float64()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Float64Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[float64]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Float64()
        if err != nil {
            return err
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Float64Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[float64]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Float64()
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    {{- range .Bytes }}

    {{- if (Deref .Accessor) }}
    x.{{ LowerFirst .Name }}, err = d.Bytes(nil)
    if err != nil {
        return err
    }
    {{- else }}
    x.{{ .Name }}, err = d.Bytes(nil)
    if err != nil {
        return err
    }
    {{- end -}}

    {{ end }}

    {{- range .BytesArrays }}

    {{- if (Deref .Accessor) }}
    sliceSize{{ LowerFirst .Name }}, err := d.Slice(polyglot.BytesKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != sliceSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make([][]byte, sliceSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < sliceSize{{ LowerFirst .Name }}; i++ {
        x.{{ LowerFirst .Name }}[i], err = d.Bytes(nil)
        if err != nil {
            return err
        }
    }
    {{- else }}
    sliceSize{{ .Name }}, err := d.Slice(polyglot.Int32Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([][]byte, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        x.{{ .Name }}[i], err = d.Bytes(nil)
        if err != nil {
            return err
        }
    }
    {{- end -}}

    {{ end }}

    {{- range .BytesMaps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.BytesKind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[[]byte]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Bytes(nil)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.BytesKind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[[]byte]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        k, err := d.Bytes(nil)
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.BytesKind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[[]byte]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Bytes(nil)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.BytesKind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[[]byte]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        k, err := d.Bytes(nil)
        if err != nil {
            return err
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    {{- range .Enums }}

    {{- if (Deref .Accessor) }}
    enumValue{{ LowerFirst .Name }}, err := d.Uint32()
    if err != nil {
        return err
    }
    {{ $current_enum := . }}
    switch Enum{{ $current_model.Name }}{{ .Name }}(enumValue{{ LowerFirst .Name }}) {
    {{- range $index, $value := .Values }}
    case Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}:
        x.{{ LowerFirst $current_enum.Name }} = Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}
    {{- end }}
    default:
        return InvalidEnum
    }
    {{- else }}
    enumValue{{ .Name }}, err := d.Uint32()
    if err != nil {
        return err
    }
    {{ $current_enum := . }}
    switch Enum{{ $current_model.Name }}{{ .Name }}(enumValue{{ .Name }}) {
    {{- range $index, $value := .Values }}
    case Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}:
        x.{{ $current_enum.Name }} = Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}
    {{- end }}
    default:
        return InvalidEnum
    }
    {{- end -}}

    {{ end }}

    {{- range .EnumArrays }}

    {{- if (Deref .Accessor) }}
    sliceSize{{ LowerFirst .Name }}, err := d.Slice(polyglot.Uint32Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != sliceSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make([]Enum{{ $current_model.Name }}{{ .Name }}, sliceSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < sliceSize{{ LowerFirst .Name }}; i++ {
        enumValue{{ LowerFirst .Name }}, err := d.Uint32()
        if err != nil {
            return err
        }
        {{ $current_enum := . }}
        switch Enum{{ $current_model.Name }}{{ .Name }}(enumValue{{ LowerFirst .Name }}) {
        {{- range $index, $value := .Values }}
        case Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}:
            x.{{ LowerFirst $current_enum.Name }}[i] = Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}
        {{- end }}
        default:
            return InvalidEnum
        }
    }
    {{- else }}
    sliceSize{{ .Name }}, err := d.Slice(polyglot.Uint32Kind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != sliceSize{{ .Name }} {
        x.{{ .Name }} = make([]Enum{{ $current_model.Name }}{{ .Name }}, sliceSize{{ .Name }})
    }

    for i := uint32(0); i < sliceSize{{ .Name }}; i++ {
        enumValue{{ .Name }}, err := d.Uint32()
        if err != nil {
            return err
        }
        {{ $current_enum := . }}
        switch Enum{{ $current_model.Name }}{{ .Name }}(enumValue{{ .Name }}) {
        {{- range $index, $value := .Values }}
        case Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}:
            x.{{ $current_enum.Name }}[i] = Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}
        {{- end }}
        default:
            return InvalidEnum
        }
    }
    {{- end -}}

    {{ end }}

    {{- range .EnumMaps }}

    {{- if and (Deref .Accessor) (IsPrimitive .Value) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Uint32Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[Enum{{ $current_model.Name }}{{ .Name }}]{{ Primitive .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        var k Enum{{ $current_model.Name }}{{ .Name }}
        enumValue{{ LowerFirst .Name }}, err := d.Uint32()
        if err != nil {
            return err
        }
        {{ $current_enum := . }}
        switch Enum{{ $current_model.Name }}{{ .Name }}(enumValue{{ LowerFirst .Name }}) {
        {{- range $index, $value := .Values }}
        case Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}:
            k = Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}
        {{- end }}
        default:
            return InvalidEnum
        }
        x.{{ LowerFirst .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (Deref .Accessor) (not (IsPrimitive .Value)) }}
    mapSize{{ LowerFirst .Name }}, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ LowerFirst .Name }})) != mapSize{{ LowerFirst .Name }} {
        x.{{ LowerFirst .Name }} = make(map[Enum{{ $current_model.Name }}{{ .Name }}]*{{ .Value }}, mapSize{{ LowerFirst .Name }})
    }

    for i := uint32(0); i < mapSize{{ LowerFirst .Name }}; i++ {
        var k Enum{{ $current_model.Name }}{{ .Name }}
        enumValue{{ LowerFirst .Name }}, err := d.Uint32()
        if err != nil {
            return err
        }
        {{ $current_enum := . }}
        switch Enum{{ $current_model.Name }}{{ .Name }}(enumValue{{ LowerFirst .Name }}) {
        {{- range $index, $value := .Values }}
        case Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}:
            k = Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}
        {{- end }}
        default:
            return InvalidEnum
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ LowerFirst .Name }}[k] = v
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (IsPrimitive .Value) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Uint32Kind, {{ PolyglotPrimitive .Value }})
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[Enum{{ $current_model.Name }}{{ .Name }}]{{ Primitive .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        var k Enum{{ $current_model.Name }}{{ .Name }}
        enumValue{{ .Name }}, err := d.Uint32()
        if err != nil {
            return err
        }
        {{ $current_enum := . }}
        switch Enum{{ $current_model.Name }}{{ .Name }}(enumValue{{ .Name }}) {
        {{- range $index, $value := .Values }}
        case Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}:
            k = Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}
        {{- end }}
        default:
            return InvalidEnum
        }
        x.{{ .Name }}[k], err = d.{{ PolyglotPrimitiveDecode .Value }}()
        if err != nil {
            return err
        }
    }
    {{- end }}

    {{- if and (not (Deref .Accessor)) (not (IsPrimitive .Value)) }}
    mapSize{{ .Name }}, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
    if err != nil {
        return err
    }

    if uint32(len(x.{{ .Name }})) != mapSize{{ .Name }} {
        x.{{ .Name }} = make(map[Enum{{ $current_model.Name }}{{ .Name }}]*{{ .Value }}, mapSize{{ .Name }})
    }

    for i := uint32(0); i < mapSize{{ .Name }}; i++ {
        var k Enum{{ $current_model.Name }}{{ .Name }}
        enumValue{{ .Name }}, err := d.Uint32()
        if err != nil {
            return err
        }
        {{ $current_enum := . }}
        switch Enum{{ $current_model.Name }}{{ .Name }}(enumValue{{ .Name }}) {
        {{- range $index, $value := .Values }}
        case Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}:
            k = Enum{{ $current_model.Name }}{{ $current_enum.Name }}{{ $value }}
        {{- end }}
        default:
            return InvalidEnum
        }
        v := New{{ .Value }}()
        err = v._decode(d)
        if err != nil {
            return err
        }
        x.{{ .Name }}[k] = v
    }
    {{- end }}

    {{ end }}

    return nil
}
{{ end -}}