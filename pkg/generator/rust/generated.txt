// Code generated by scale-signature-rs v0.1.0, DO NOT EDIT.
// schema: MasterSchema:MasterSchemaTag
// output: types.rs

use num_enum::TryFromPrimitive;
use polyglot_rs::{Decoder, DecodingError, Encoder, Kind};
use regex::Regex;
use std::collections::HashMap;
use std::convert::TryFrom;
use std::io::Cursor;

pub trait Encode {
    fn encode<'a>(
        &'a self,
        b: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>>;
}

pub trait Decode {
    fn decode(b: &mut Cursor<&mut Vec<u8>>) -> Result<Self, Box<dyn std::error::Error>>
    where
        Self: Sized;
}

#[derive(Debug, Eq, PartialEq, TryFromPrimitive, Copy, Clone, Hash)]
#[repr(u32)]
pub enum GenericEnum {
    FirstValue = 0,
    SecondValue = 1,
    DefaultValue = 2,
}
pub(crate) struct EmptyModel {}

impl EmptyModel {
    pub(crate) fn new() -> Self {
        Self {}
    }
}

impl Encode for EmptyModel {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        Ok(e)
    }
}

impl Encode for Option<EmptyModel> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for EmptyModel {
    fn decode(d: &mut Cursor<&mut Vec<u8>>) -> Result<EmptyModel, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = EmptyModel::new();

        Ok(x)
    }
}

impl Decode for Option<EmptyModel> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<EmptyModel>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = EmptyModel::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

// EmptyModelWithDescription: Test Description
pub(crate) struct EmptyModelWithDescription {}

impl EmptyModelWithDescription {
    pub(crate) fn new() -> Self {
        Self {}
    }
}

impl Encode for EmptyModelWithDescription {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        Ok(e)
    }
}

impl Encode for Option<EmptyModelWithDescription> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for EmptyModelWithDescription {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<EmptyModelWithDescription, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = EmptyModelWithDescription::new();

        Ok(x)
    }
}

impl Decode for Option<EmptyModelWithDescription> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<EmptyModelWithDescription>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = EmptyModelWithDescription::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

pub(crate) struct ModelWithSingleStringField {
    pub string_field: String,
}

impl ModelWithSingleStringField {
    pub(crate) fn new() -> Self {
        Self {
            string_field: "DefaultValue".to_string(),
        }
    }
}

impl Encode for ModelWithSingleStringField {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_string(&self.string_field)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithSingleStringField> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithSingleStringField {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithSingleStringField, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithSingleStringField::new();

        x.string_field = d.decode_string()?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithSingleStringField> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithSingleStringField>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithSingleStringField::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

// ModelWithSingleStringFieldAndDescription: Test Description
pub(crate) struct ModelWithSingleStringFieldAndDescription {
    pub string_field: String,
}

impl ModelWithSingleStringFieldAndDescription {
    pub(crate) fn new() -> Self {
        Self {
            string_field: "DefaultValue".to_string(),
        }
    }
}

impl Encode for ModelWithSingleStringFieldAndDescription {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_string(&self.string_field)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithSingleStringFieldAndDescription> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithSingleStringFieldAndDescription {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithSingleStringFieldAndDescription, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithSingleStringFieldAndDescription::new();

        x.string_field = d.decode_string()?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithSingleStringFieldAndDescription> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithSingleStringFieldAndDescription>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithSingleStringFieldAndDescription::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

pub(crate) struct ModelWithSingleInt32Field {
    pub int32_field: i32,
}

impl ModelWithSingleInt32Field {
    pub(crate) fn new() -> Self {
        Self { int32_field: 32 }
    }
}

impl Encode for ModelWithSingleInt32Field {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_i32(self.int32_field)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithSingleInt32Field> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithSingleInt32Field {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithSingleInt32Field, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithSingleInt32Field::new();

        x.int32_field = d.decode_i32()?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithSingleInt32Field> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithSingleInt32Field>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithSingleInt32Field::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

// ModelWithSingleInt32FieldAndDescription: Test Description
pub(crate) struct ModelWithSingleInt32FieldAndDescription {
    pub int32_field: i32,
}

impl ModelWithSingleInt32FieldAndDescription {
    pub(crate) fn new() -> Self {
        Self { int32_field: 32 }
    }
}

impl Encode for ModelWithSingleInt32FieldAndDescription {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_i32(self.int32_field)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithSingleInt32FieldAndDescription> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithSingleInt32FieldAndDescription {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithSingleInt32FieldAndDescription, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithSingleInt32FieldAndDescription::new();

        x.int32_field = d.decode_i32()?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithSingleInt32FieldAndDescription> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithSingleInt32FieldAndDescription>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithSingleInt32FieldAndDescription::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

pub(crate) struct ModelWithMultipleFields {
    pub string_field: String,

    pub int32_field: i32,
}

impl ModelWithMultipleFields {
    pub(crate) fn new() -> Self {
        Self {
            string_field: "DefaultValue".to_string(),

            int32_field: 32,
        }
    }
}

impl Encode for ModelWithMultipleFields {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_string(&self.string_field)?;

        e.encode_i32(self.int32_field)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithMultipleFields> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithMultipleFields {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithMultipleFields, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithMultipleFields::new();

        x.string_field = d.decode_string()?;

        x.int32_field = d.decode_i32()?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithMultipleFields> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithMultipleFields>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithMultipleFields::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

// ModelWithMultipleFieldsAndDescription: Test Description
pub(crate) struct ModelWithMultipleFieldsAndDescription {
    pub string_field: String,

    pub int32_field: i32,
}

impl ModelWithMultipleFieldsAndDescription {
    pub(crate) fn new() -> Self {
        Self {
            string_field: "DefaultValue".to_string(),

            int32_field: 32,
        }
    }
}

impl Encode for ModelWithMultipleFieldsAndDescription {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_string(&self.string_field)?;

        e.encode_i32(self.int32_field)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithMultipleFieldsAndDescription> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithMultipleFieldsAndDescription {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithMultipleFieldsAndDescription, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithMultipleFieldsAndDescription::new();

        x.string_field = d.decode_string()?;

        x.int32_field = d.decode_i32()?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithMultipleFieldsAndDescription> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithMultipleFieldsAndDescription>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithMultipleFieldsAndDescription::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

pub(crate) struct ModelWithEnum {
    pub enum_field: GenericEnum,
}

impl ModelWithEnum {
    pub(crate) fn new() -> Self {
        Self {
            enum_field: GenericEnum::DefaultValue,
        }
    }
}

impl Encode for ModelWithEnum {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_u32(self.enum_field as u32)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithEnum> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithEnum {
    fn decode(d: &mut Cursor<&mut Vec<u8>>) -> Result<ModelWithEnum, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithEnum::new();

        x.enum_field = GenericEnum::try_from(d.decode_u32()?)
            .ok()
            .ok_or(DecodingError::InvalidEnum)?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithEnum> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithEnum>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithEnum::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

// ModelWithEnumAndDescription: Test Description
pub(crate) struct ModelWithEnumAndDescription {
    pub enum_field: GenericEnum,
}

impl ModelWithEnumAndDescription {
    pub(crate) fn new() -> Self {
        Self {
            enum_field: GenericEnum::DefaultValue,
        }
    }
}

impl Encode for ModelWithEnumAndDescription {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_u32(self.enum_field as u32)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithEnumAndDescription> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithEnumAndDescription {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithEnumAndDescription, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithEnumAndDescription::new();

        x.enum_field = GenericEnum::try_from(d.decode_u32()?)
            .ok()
            .ok_or(DecodingError::InvalidEnum)?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithEnumAndDescription> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithEnumAndDescription>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithEnumAndDescription::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

pub(crate) struct ModelWithEnumAccessor {
    enum_field: GenericEnum,
}

impl ModelWithEnumAccessor {
    pub(crate) fn new() -> Self {
        Self {
            enum_field: GenericEnum::DefaultValue,
        }
    }
}

impl Encode for ModelWithEnumAccessor {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_u32(self.enum_field as u32)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithEnumAccessor> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithEnumAccessor {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithEnumAccessor, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithEnumAccessor::new();

        x.enum_field = GenericEnum::try_from(d.decode_u32()?)
            .ok()
            .ok_or(DecodingError::InvalidEnum)?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithEnumAccessor> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithEnumAccessor>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithEnumAccessor::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

// ModelWithEnumAccessorAndDescription: Test Description
pub(crate) struct ModelWithEnumAccessorAndDescription {
    enum_field: GenericEnum,
}

impl ModelWithEnumAccessorAndDescription {
    pub(crate) fn new() -> Self {
        Self {
            enum_field: GenericEnum::DefaultValue,
        }
    }
}

impl Encode for ModelWithEnumAccessorAndDescription {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_u32(self.enum_field as u32)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithEnumAccessorAndDescription> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithEnumAccessorAndDescription {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithEnumAccessorAndDescription, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithEnumAccessorAndDescription::new();

        x.enum_field = GenericEnum::try_from(d.decode_u32()?)
            .ok()
            .ok_or(DecodingError::InvalidEnum)?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithEnumAccessorAndDescription> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithEnumAccessorAndDescription>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithEnumAccessorAndDescription::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

pub(crate) struct ModelWithMultipleFieldsAccessor {
    string_field: String,

    int32_field: i32,
}

impl ModelWithMultipleFieldsAccessor {
    pub(crate) fn new() -> Self {
        Self {
            string_field: "DefaultValue".to_string(),

            int32_field: 32,
        }
    }

    fn get_string_field(&self) -> String {
        self.string_field.clone()
    }

    fn set_string_field(&mut self, mut v: String) -> Result<(), Box<dyn std::error::Error>> {
        if !Regex::new("^[a-zA-Z0-9]*$")?.is_match(v.as_str()) {
            return Err(Box::<dyn std::error::Error>::from(
                "value must match ^[a-zA-Z0-9]*$",
            ));
        }

        if v.len() > 20 || v.len() < 1 {
            return Err(Box::<dyn std::error::Error>::from(
                "value must be between { .Minimum }} and 20",
            ));
        }

        v = v.to_uppercase();

        self.string_field = v;
        Ok(())
    }

    fn get_int32_field(&self) -> i32 {
        self.int32_field
    }

    fn set_int32_field(&mut self, v: i32) -> Result<(), Box<dyn std::error::Error>> {
        if v > 100 || v < 0 {
            return Err(Box::<dyn std::error::Error>::from(
                "value must be between { .Minimum }} and 100",
            ));
        }

        self.int32_field = v;
        Ok(())
    }
}

impl Encode for ModelWithMultipleFieldsAccessor {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_string(&self.string_field)?;

        e.encode_i32(self.int32_field)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithMultipleFieldsAccessor> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithMultipleFieldsAccessor {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithMultipleFieldsAccessor, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithMultipleFieldsAccessor::new();

        x.string_field = d.decode_string()?;

        x.int32_field = d.decode_i32()?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithMultipleFieldsAccessor> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithMultipleFieldsAccessor>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithMultipleFieldsAccessor::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

// ModelWithMultipleFieldsAccessorAndDescription: Test Description
pub(crate) struct ModelWithMultipleFieldsAccessorAndDescription {
    string_field: String,

    int32_field: i32,
}

impl ModelWithMultipleFieldsAccessorAndDescription {
    pub(crate) fn new() -> Self {
        Self {
            string_field: "DefaultValue".to_string(),

            int32_field: 32,
        }
    }

    fn get_string_field(&self) -> String {
        self.string_field.clone()
    }

    fn set_string_field(&mut self, mut v: String) -> Result<(), Box<dyn std::error::Error>> {
        self.string_field = v;
        Ok(())
    }

    fn get_int32_field(&self) -> i32 {
        self.int32_field
    }

    fn set_int32_field(&mut self, v: i32) -> Result<(), Box<dyn std::error::Error>> {
        self.int32_field = v;
        Ok(())
    }
}

impl Encode for ModelWithMultipleFieldsAccessorAndDescription {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        e.encode_string(&self.string_field)?;

        e.encode_i32(self.int32_field)?;

        Ok(e)
    }
}

impl Encode for Option<ModelWithMultipleFieldsAccessorAndDescription> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithMultipleFieldsAccessorAndDescription {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithMultipleFieldsAccessorAndDescription, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithMultipleFieldsAccessorAndDescription::new();

        x.string_field = d.decode_string()?;

        x.int32_field = d.decode_i32()?;

        Ok(x)
    }
}

impl Decode for Option<ModelWithMultipleFieldsAccessorAndDescription> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithMultipleFieldsAccessorAndDescription>, Box<dyn std::error::Error>>
    {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithMultipleFieldsAccessorAndDescription::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

pub(crate) struct ModelWithEmbeddedModels {
    pub embedded_empty_model: Option<EmptyModel>,

    pub embedded_model_array_with_multiple_fields_accessor: Vec<ModelWithMultipleFieldsAccessor>,
}

impl ModelWithEmbeddedModels {
    pub(crate) fn new() -> Self {
        Self {
            embedded_empty_model: None,

            embedded_model_array_with_multiple_fields_accessor: Vec::new(),
        }
    }
}

impl Encode for ModelWithEmbeddedModels {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        self.embedded_empty_model.encode(e)?;

        e.encode_array(
            self.embedded_model_array_with_multiple_fields_accessor
                .len(),
            Kind::Any,
        )?;
        for a in &self.embedded_model_array_with_multiple_fields_accessor {
            a.encode(e)?;
        }

        Ok(e)
    }
}

impl Encode for Option<ModelWithEmbeddedModels> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithEmbeddedModels {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithEmbeddedModels, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithEmbeddedModels::new();

        x.embedded_empty_model = Option::<EmptyModel>::decode(d)?;

        let size_embedded_model_array_with_multiple_fields_accessor = d.decode_array(Kind::Any)?;
        for _ in 0..size_embedded_model_array_with_multiple_fields_accessor {
            x.embedded_model_array_with_multiple_fields_accessor
                .push(ModelWithMultipleFieldsAccessor::decode(d)?);
        }

        Ok(x)
    }
}

impl Decode for Option<ModelWithEmbeddedModels> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithEmbeddedModels>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithEmbeddedModels::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

// ModelWithEmbeddedModelsAndDescription: Test Description
pub(crate) struct ModelWithEmbeddedModelsAndDescription {
    pub embedded_empty_model: Option<EmptyModel>,

    pub embedded_model_array_with_multiple_fields_accessor: Vec<ModelWithMultipleFieldsAccessor>,
}

impl ModelWithEmbeddedModelsAndDescription {
    pub(crate) fn new() -> Self {
        Self {
            embedded_empty_model: None,

            embedded_model_array_with_multiple_fields_accessor: Vec::new(),
        }
    }
}

impl Encode for ModelWithEmbeddedModelsAndDescription {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        self.embedded_empty_model.encode(e)?;

        e.encode_array(
            self.embedded_model_array_with_multiple_fields_accessor
                .len(),
            Kind::Any,
        )?;
        for a in &self.embedded_model_array_with_multiple_fields_accessor {
            a.encode(e)?;
        }

        Ok(e)
    }
}

impl Encode for Option<ModelWithEmbeddedModelsAndDescription> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithEmbeddedModelsAndDescription {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithEmbeddedModelsAndDescription, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithEmbeddedModelsAndDescription::new();

        x.embedded_empty_model = Option::<EmptyModel>::decode(d)?;

        let size_embedded_model_array_with_multiple_fields_accessor = d.decode_array(Kind::Any)?;
        for _ in 0..size_embedded_model_array_with_multiple_fields_accessor {
            x.embedded_model_array_with_multiple_fields_accessor
                .push(ModelWithMultipleFieldsAccessor::decode(d)?);
        }

        Ok(x)
    }
}

impl Decode for Option<ModelWithEmbeddedModelsAndDescription> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithEmbeddedModelsAndDescription>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithEmbeddedModelsAndDescription::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

pub(crate) struct ModelWithEmbeddedModelsAccessor {
    embedded_empty_model: Option<EmptyModel>,

    embedded_model_array_with_multiple_fields_accessor: Vec<ModelWithMultipleFieldsAccessor>,
}

impl ModelWithEmbeddedModelsAccessor {
    pub(crate) fn new() -> Self {
        Self {
            embedded_empty_model: None,

            embedded_model_array_with_multiple_fields_accessor: Vec::new(),
        }
    }
}

impl Encode for ModelWithEmbeddedModelsAccessor {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        self.embedded_empty_model.encode(e)?;

        e.encode_array(
            self.embedded_model_array_with_multiple_fields_accessor
                .len(),
            Kind::Any,
        )?;
        for a in &self.embedded_model_array_with_multiple_fields_accessor {
            a.encode(e)?;
        }

        Ok(e)
    }
}

impl Encode for Option<ModelWithEmbeddedModelsAccessor> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithEmbeddedModelsAccessor {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithEmbeddedModelsAccessor, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithEmbeddedModelsAccessor::new();

        x.embedded_empty_model = Option::<EmptyModel>::decode(d)?;

        let size_embedded_model_array_with_multiple_fields_accessor = d.decode_array(Kind::Any)?;
        for _ in 0..size_embedded_model_array_with_multiple_fields_accessor {
            x.embedded_model_array_with_multiple_fields_accessor
                .push(ModelWithMultipleFieldsAccessor::decode(d)?);
        }

        Ok(x)
    }
}

impl Decode for Option<ModelWithEmbeddedModelsAccessor> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithEmbeddedModelsAccessor>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithEmbeddedModelsAccessor::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

impl ModelWithEmbeddedModelsAccessor {
    pub fn get_embedded_empty_model(&self) -> &Option<EmptyModel> {
        &self.embedded_empty_model
    }

    pub fn set_embedded_empty_model(&mut self, v: Option<EmptyModel>) {
        self.embedded_empty_model = v;
    }
}

impl ModelWithEmbeddedModelsAccessor {
    fn get_embedded_model_array_with_multiple_fields_accessor(
        &self,
    ) -> Result<&Vec<ModelWithMultipleFieldsAccessor>, Box<dyn std::error::Error>> {
        Ok(&self.embedded_model_array_with_multiple_fields_accessor)
    }

    fn set_embedded_model_array_with_multiple_fields_accessor(
        &mut self,
        v: Vec<ModelWithMultipleFieldsAccessor>,
    ) {
        self.embedded_model_array_with_multiple_fields_accessor = v;
    }
}

// ModelWithEmbeddedModelsAccessorAndDescription: Test Description
pub(crate) struct ModelWithEmbeddedModelsAccessorAndDescription {
    embedded_empty_model: Option<EmptyModel>,

    embedded_model_array_with_multiple_fields_accessor: Vec<ModelWithMultipleFieldsAccessor>,
}

impl ModelWithEmbeddedModelsAccessorAndDescription {
    pub(crate) fn new() -> Self {
        Self {
            embedded_empty_model: None,

            embedded_model_array_with_multiple_fields_accessor: Vec::new(),
        }
    }
}

impl Encode for ModelWithEmbeddedModelsAccessorAndDescription {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        self.embedded_empty_model.encode(e)?;

        e.encode_array(
            self.embedded_model_array_with_multiple_fields_accessor
                .len(),
            Kind::Any,
        )?;
        for a in &self.embedded_model_array_with_multiple_fields_accessor {
            a.encode(e)?;
        }

        Ok(e)
    }
}

impl Encode for Option<ModelWithEmbeddedModelsAccessorAndDescription> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithEmbeddedModelsAccessorAndDescription {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithEmbeddedModelsAccessorAndDescription, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithEmbeddedModelsAccessorAndDescription::new();

        x.embedded_empty_model = Option::<EmptyModel>::decode(d)?;

        let size_embedded_model_array_with_multiple_fields_accessor = d.decode_array(Kind::Any)?;
        for _ in 0..size_embedded_model_array_with_multiple_fields_accessor {
            x.embedded_model_array_with_multiple_fields_accessor
                .push(ModelWithMultipleFieldsAccessor::decode(d)?);
        }

        Ok(x)
    }
}

impl Decode for Option<ModelWithEmbeddedModelsAccessorAndDescription> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithEmbeddedModelsAccessorAndDescription>, Box<dyn std::error::Error>>
    {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithEmbeddedModelsAccessorAndDescription::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}

impl ModelWithEmbeddedModelsAccessorAndDescription {
    pub fn get_embedded_empty_model(&self) -> &Option<EmptyModel> {
        &self.embedded_empty_model
    }

    pub fn set_embedded_empty_model(&mut self, v: Option<EmptyModel>) {
        self.embedded_empty_model = v;
    }
}

impl ModelWithEmbeddedModelsAccessorAndDescription {
    fn get_embedded_model_array_with_multiple_fields_accessor(
        &self,
    ) -> Result<&Vec<ModelWithMultipleFieldsAccessor>, Box<dyn std::error::Error>> {
        Ok(&self.embedded_model_array_with_multiple_fields_accessor)
    }

    fn set_embedded_model_array_with_multiple_fields_accessor(
        &mut self,
        v: Vec<ModelWithMultipleFieldsAccessor>,
    ) {
        self.embedded_model_array_with_multiple_fields_accessor = v;
    }
}

pub(crate) struct ModelWithAllFieldTypes {
    pub model_field: Option<EmptyModel>,

    pub model_array_field: Vec<EmptyModel>,

    pub string_field: String,

    pub string_array_field: Vec<String>,

    pub string_map_field: HashMap<String, String>,

    pub string_map_field_embedded: HashMap<String, EmptyModel>,

    pub int32_field: i32,

    pub int32_array_field: Vec<i32>,

    pub int32_map_field: HashMap<i32, i32>,

    pub int32_map_field_embedded: HashMap<i32, EmptyModel>,

    pub int64_field: i64,

    pub int64_array_field: Vec<i64>,

    pub int64_map_field: HashMap<i64, i64>,

    pub int64_map_field_embedded: HashMap<i64, EmptyModel>,

    pub uint32_field: u32,

    pub uint32_array_field: Vec<u32>,

    pub uint32_map_field: HashMap<u32, u32>,

    pub uint32_map_field_embedded: HashMap<u32, EmptyModel>,

    pub uint64_field: u64,

    pub uint64_array_field: Vec<u64>,

    pub uint64_map_field: HashMap<u64, u64>,

    pub uint64_map_field_embedded: HashMap<u64, EmptyModel>,

    pub float32_field: f32,

    pub float32_array_field: Vec<f32>,

    pub float64_field: f64,

    pub float64_array_field: Vec<f64>,

    pub enum_field: GenericEnum,

    pub enum_array_field: Vec<GenericEnum>,

    pub enum_map_field: HashMap<GenericEnum, String>,
    pub enum_map_field_embedded: HashMap<GenericEnum, EmptyModel>,

    pub bytes_field: Vec<u8>,

    pub bytes_array_field: Vec<Vec<u8>>,

    pub bool_field: bool,

    pub bool_array_field: Vec<bool>,
}

impl ModelWithAllFieldTypes {
    pub(crate) fn new() -> Self {
        Self {
            model_field: None,

            model_array_field: Vec::new(),

            string_field: "DefaultValue".to_string(),

            string_array_field: Vec::with_capacity(0),

            string_map_field: HashMap::new(),
            string_map_field_embedded: HashMap::new(),

            int32_field: 32,

            int32_array_field: Vec::with_capacity(0),

            int32_map_field: HashMap::new(),
            int32_map_field_embedded: HashMap::new(),

            int64_field: 64,

            int64_array_field: Vec::with_capacity(0),

            int64_map_field: HashMap::new(),
            int64_map_field_embedded: HashMap::new(),

            uint32_field: 32,

            uint32_array_field: Vec::with_capacity(0),

            uint32_map_field: HashMap::new(),
            uint32_map_field_embedded: HashMap::new(),

            uint64_field: 64,

            uint64_array_field: Vec::with_capacity(0),

            uint64_map_field: HashMap::new(),
            uint64_map_field_embedded: HashMap::new(),

            float32_field: 32.32,

            float32_array_field: Vec::with_capacity(0),

            float64_field: 64.64,

            float64_array_field: Vec::with_capacity(0),

            enum_field: GenericEnum::DefaultValue,

            enum_array_field: Vec::with_capacity(0),

            enum_map_field: HashMap::new(),

            enum_map_field_embedded: HashMap::new(),

            bytes_field: Vec::new(),

            bytes_array_field: Vec::with_capacity(0),

            bool_field: true,

            bool_array_field: Vec::with_capacity(0),
        }
    }
}

impl Encode for ModelWithAllFieldTypes {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        self.model_field.encode(e)?;

        e.encode_array(self.model_array_field.len(), Kind::Any)?;
        for a in &self.model_array_field {
            a.encode(e)?;
        }

        e.encode_string(&self.string_field)?;

        e.encode_array(self.string_array_field.len(), Kind::String)?;
        for a in &self.string_array_field {
            e.encode_string(&a)?;
        }

        e.encode_map(self.string_map_field.len(), Kind::String, Kind::String)?;
        for (k, v) in &self.string_map_field {
            e.encode_string(&k)?;
            e.encode_string(&v)?;
        }
        e.encode_map(
            self.string_map_field_embedded.len(),
            Kind::String,
            Kind::Any,
        )?;
        for (k, v) in &self.string_map_field_embedded {
            e.encode_string(&k)?;
            v.encode(e)?;
        }

        e.encode_i32(self.int32_field)?;

        e.encode_array(self.int32_array_field.len(), Kind::I32)?;
        for a in &self.int32_array_field {
            e.encode_i32(*a)?;
        }

        e.encode_map(self.int32_map_field.len(), Kind::I32, Kind::I32)?;
        for (k, v) in &self.int32_map_field {
            e.encode_i32(*k)?;
            e.encode_i32(*v)?;
        }
        e.encode_map(self.int32_map_field_embedded.len(), Kind::I32, Kind::Any)?;
        for (k, v) in &self.int32_map_field_embedded {
            e.encode_i32(*k)?;
            v.encode(e)?;
        }

        e.encode_i64(self.int64_field)?;

        e.encode_array(self.int64_array_field.len(), Kind::I64)?;
        for a in &self.int64_array_field {
            e.encode_i64(*a)?;
        }

        e.encode_map(self.int64_map_field.len(), Kind::I64, Kind::I64)?;
        for (k, v) in &self.int64_map_field {
            e.encode_i64(*k)?;
            e.encode_i64(*v)?;
        }
        e.encode_map(self.int64_map_field_embedded.len(), Kind::I64, Kind::Any)?;
        for (k, v) in &self.int64_map_field_embedded {
            e.encode_i64(*k)?;
            v.encode(e)?;
        }

        e.encode_u32(self.uint32_field)?;

        e.encode_array(self.uint32_array_field.len(), Kind::U32)?;
        for a in &self.uint32_array_field {
            e.encode_u32(*a)?;
        }

        e.encode_map(self.uint32_map_field.len(), Kind::U32, Kind::U32)?;
        for (k, v) in &self.uint32_map_field {
            e.encode_u32(*k)?;
            e.encode_u32(*v)?;
        }
        e.encode_map(self.uint32_map_field_embedded.len(), Kind::U32, Kind::Any)?;
        for (k, v) in &self.uint32_map_field_embedded {
            e.encode_u32(*k)?;
            v.encode(e)?;
        }

        e.encode_u64(self.uint64_field)?;

        e.encode_array(self.uint64_array_field.len(), Kind::U64)?;
        for a in &self.uint64_array_field {
            e.encode_u64(*a)?;
        }

        e.encode_map(self.uint64_map_field.len(), Kind::U64, Kind::U64)?;
        for (k, v) in &self.uint64_map_field {
            e.encode_u64(*k)?;
            e.encode_u64(*v)?;
        }
        e.encode_map(self.uint64_map_field_embedded.len(), Kind::U64, Kind::Any)?;
        for (k, v) in &self.uint64_map_field_embedded {
            e.encode_u64(*k)?;
            v.encode(e)?;
        }

        e.encode_f32(self.float32_field)?;

        e.encode_array(self.float32_array_field.len(), Kind::F32)?;
        for a in &self.float32_array_field {
            e.encode_f32(*a)?;
        }

        e.encode_f64(self.float64_field)?;

        e.encode_array(self.float64_array_field.len(), Kind::F64)?;
        for a in &self.float64_array_field {
            e.encode_f64(*a)?;
        }

        e.encode_u32(self.enum_field as u32)?;

        e.encode_array(self.enum_array_field.len(), Kind::U32)?;
        for a in &self.enum_array_field {
            e.encode_u32(*a as u32)?;
        }

        e.encode_map(self.enum_map_field.len(), Kind::U32, Kind::String)?;
        for (k, v) in &self.enum_map_field {
            e.encode_u32(*k as u32)?;
            e.encode_string(&v)?;
        }
        e.encode_map(self.enum_map_field_embedded.len(), Kind::U32, Kind::Any)?;
        for (k, v) in &self.enum_map_field_embedded {
            e.encode_u32(*k as u32)?;
            v.encode(e)?;
        }

        e.encode_bytes(&self.bytes_field)?;

        e.encode_array(self.bytes_array_field.len(), Kind::Bytes)?;
        for a in &self.bytes_array_field {
            e.encode_bytes(&a)?;
        }

        e.encode_bool(self.bool_field)?;

        e.encode_array(self.bool_array_field.len(), Kind::Bool)?;
        for a in &self.bool_array_field {
            e.encode_bool(*a)?;
        }

        Ok(e)
    }
}

impl Encode for Option<ModelWithAllFieldTypes> {
    fn encode<'a>(
        &'a self,
        e: &'a mut Cursor<Vec<u8>>,
    ) -> Result<&mut Cursor<Vec<u8>>, Box<dyn std::error::Error>> {
        if let Some(x) = self {
            x.encode(e)?;
        } else {
            e.encode_none()?;
        }
        Ok(e)
    }
}

impl Decode for ModelWithAllFieldTypes {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<ModelWithAllFieldTypes, Box<dyn std::error::Error>> {
        if let Ok(error) = d.decode_error() {
            return Err(error);
        }

        let mut x = ModelWithAllFieldTypes::new();

        x.model_field = Option::<EmptyModel>::decode(d)?;

        let size_model_array_field = d.decode_array(Kind::Any)?;
        for _ in 0..size_model_array_field {
            x.model_array_field.push(EmptyModel::decode(d)?);
        }

        x.string_field = d.decode_string()?;

        let size_string_array_field = d.decode_array(Kind::String)?;
        for _ in 0..size_string_array_field {
            x.string_array_field.push(d.decode_string()?);
        }

        let size_string_map_field = d.decode_map(Kind::String, Kind::String)?;
        for _ in 0..size_string_map_field {
            let k = d.decode_string()?;
            let v = d.decode_string()?;
            x.string_map_field.insert(k, v);
        }
        let size_string_map_field_embedded = d.decode_map(Kind::String, Kind::Any)?;
        for _ in 0..size_string_map_field_embedded {
            let k = d.decode_string()?;
            let v = EmptyModel::decode(d)?;
            x.string_map_field_embedded.insert(k, v);
        }

        x.int32_field = d.decode_i32()?;

        let size_int32_array_field = d.decode_array(Kind::I32)?;
        for _ in 0..size_int32_array_field {
            x.int32_array_field.push(d.decode_i32()?);
        }

        let size_int32_map_field = d.decode_map(Kind::I32, Kind::I32)?;
        for _ in 0..size_int32_map_field {
            let k = d.decode_i32()?;
            let v = d.decode_i32()?;
            x.int32_map_field.insert(k, v);
        }
        let size_int32_map_field_embedded = d.decode_map(Kind::I32, Kind::Any)?;
        for _ in 0..size_int32_map_field_embedded {
            let k = d.decode_i32()?;
            let v = EmptyModel::decode(d)?;
            x.int32_map_field_embedded.insert(k, v);
        }

        x.int64_field = d.decode_i64()?;

        let size_int64_array_field = d.decode_array(Kind::I64)?;
        for _ in 0..size_int64_array_field {
            x.int64_array_field.push(d.decode_i64()?);
        }

        let size_int64_map_field = d.decode_map(Kind::I64, Kind::I64)?;
        for _ in 0..size_int64_map_field {
            let k = d.decode_i64()?;
            let v = d.decode_i64()?;
            x.int64_map_field.insert(k, v);
        }
        let size_int64_map_field_embedded = d.decode_map(Kind::I64, Kind::Any)?;
        for _ in 0..size_int64_map_field_embedded {
            let k = d.decode_i64()?;
            let v = EmptyModel::decode(d)?;
            x.int64_map_field_embedded.insert(k, v);
        }

        x.uint32_field = d.decode_u32()?;

        let size_uint32_array_field = d.decode_array(Kind::U32)?;
        for _ in 0..size_uint32_array_field {
            x.uint32_array_field.push(d.decode_u32()?);
        }

        let size_uint32_map_field = d.decode_map(Kind::U32, Kind::U32)?;
        for _ in 0..size_uint32_map_field {
            let k = d.decode_u32()?;
            let v = d.decode_u32()?;
            x.uint32_map_field.insert(k, v);
        }
        let size_uint32_map_field_embedded = d.decode_map(Kind::U32, Kind::Any)?;
        for _ in 0..size_uint32_map_field_embedded {
            let k = d.decode_u32()?;
            let v = EmptyModel::decode(d)?;
            x.uint32_map_field_embedded.insert(k, v);
        }

        x.uint64_field = d.decode_u64()?;

        let size_uint64_array_field = d.decode_array(Kind::U64)?;
        for _ in 0..size_uint64_array_field {
            x.uint64_array_field.push(d.decode_u64()?);
        }

        let size_uint64_map_field = d.decode_map(Kind::U64, Kind::U64)?;
        for _ in 0..size_uint64_map_field {
            let k = d.decode_u64()?;
            let v = d.decode_u64()?;
            x.uint64_map_field.insert(k, v);
        }
        let size_uint64_map_field_embedded = d.decode_map(Kind::U64, Kind::Any)?;
        for _ in 0..size_uint64_map_field_embedded {
            let k = d.decode_u64()?;
            let v = EmptyModel::decode(d)?;
            x.uint64_map_field_embedded.insert(k, v);
        }

        x.float32_field = d.decode_f32()?;

        let size_float32_array_field = d.decode_array(Kind::F32)?;
        for _ in 0..size_float32_array_field {
            x.float32_array_field.push(d.decode_f32()?);
        }

        x.float64_field = d.decode_f64()?;

        let size_float64_array_field = d.decode_array(Kind::F64)?;
        for _ in 0..size_float64_array_field {
            x.float64_array_field.push(d.decode_f64()?);
        }

        x.enum_field = GenericEnum::try_from(d.decode_u32()?)
            .ok()
            .ok_or(DecodingError::InvalidEnum)?;

        let size_enum_array_field = d.decode_array(Kind::U32)?;
        for _ in 0..size_enum_array_field {
            x.enum_array_field
                .push(GenericEnum::try_from(d.decode_u32()?)?);
        }

        let size_enum_map_field = d.decode_map(Kind::U32, Kind::String)?;
        for _ in 0..size_enum_map_field {
            let k = GenericEnum::try_from(d.decode_u32()?)?;
            let v = d.decode_string()?;
            x.enum_map_field.insert(k, v);
        }
        let size_enum_map_field_embedded = d.decode_map(Kind::U32, Kind::Any)?;
        for _ in 0..size_enum_map_field_embedded {
            let k = GenericEnum::try_from(d.decode_u32()?)?;
            let v = EmptyModel::decode(d)?;
            x.enum_map_field_embedded.insert(k, v);
        }

        x.bytes_field = d.decode_bytes()?;

        let size_bytes_array_field = d.decode_array(Kind::Bytes)?;
        for _ in 0..size_bytes_array_field {
            x.bytes_array_field.push(d.decode_bytes()?);
        }

        x.bool_field = d.decode_bool()?;

        let size_bool_array_field = d.decode_array(Kind::Bool)?;
        for _ in 0..size_bool_array_field {
            x.bool_array_field.push(d.decode_bool()?);
        }

        Ok(x)
    }
}

impl Decode for Option<ModelWithAllFieldTypes> {
    fn decode(
        d: &mut Cursor<&mut Vec<u8>>,
    ) -> Result<Option<ModelWithAllFieldTypes>, Box<dyn std::error::Error>> {
        if d.decode_none() {
            return Ok(None);
        }

        let result = ModelWithAllFieldTypes::decode(d);
        if let Ok(x) = result {
            return Ok(Some(x));
        }
        return Err(result.err().unwrap());
    }
}
