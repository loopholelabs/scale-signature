// Code generated by scale-signature-go v0.1.0, DO NOT EDIT.
// schema: MasterSchema:MasterSchemaTag
// output: types.go

package golang_tests

import (
	"errors"
	"fmt"
	"github.com/loopholelabs/polyglot-go"
	"regexp"
	"strings"
)

var (
	NilDecode   = errors.New("cannot decode into a nil root struct")
	InvalidEnum = errors.New("invalid enum value")
)

type GenericEnum uint32

const (
	GenericEnumFirstValue GenericEnum = 0

	GenericEnumSecondValue GenericEnum = 1

	GenericEnumDefaultValue GenericEnum = 2
)

func decodeGenericEnum(d *polyglot.Decoder) (GenericEnum, error) {
	enumValue, err := d.Uint32()
	if err != nil {
		return 0, err
	}
	switch GenericEnum(enumValue) {
	case GenericEnumFirstValue:
		return GenericEnumFirstValue, nil
	case GenericEnumSecondValue:
		return GenericEnumSecondValue, nil
	case GenericEnumDefaultValue:
		return GenericEnumDefaultValue, nil
	default:
		return 0, InvalidEnum
	}
}

type EmptyModel struct {
}

func NewEmptyModel() *EmptyModel {
	return &EmptyModel{}
}

func (x *EmptyModel) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

	}
}

func (x *EmptyModel) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *EmptyModel) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	return nil
}

// EmptyModelWithDescription: Test Description
type EmptyModelWithDescription struct {
}

func NewEmptyModelWithDescription() *EmptyModelWithDescription {
	return &EmptyModelWithDescription{}
}

func (x *EmptyModelWithDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

	}
}

func (x *EmptyModelWithDescription) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *EmptyModelWithDescription) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	return nil
}

type ModelWithSingleStringField struct {
	StringField string
}

func NewModelWithSingleStringField() *ModelWithSingleStringField {
	return &ModelWithSingleStringField{

		StringField: "DefaultValue",
	}
}

func (x *ModelWithSingleStringField) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.StringField)

	}
}

func (x *ModelWithSingleStringField) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithSingleStringField) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	x.StringField, err = d.String()
	if err != nil {
		return err
	}

	return nil
}

// ModelWithSingleStringFieldAndDescription: Test Description
type ModelWithSingleStringFieldAndDescription struct {
	StringField string
}

func NewModelWithSingleStringFieldAndDescription() *ModelWithSingleStringFieldAndDescription {
	return &ModelWithSingleStringFieldAndDescription{

		StringField: "DefaultValue",
	}
}

func (x *ModelWithSingleStringFieldAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.StringField)

	}
}

func (x *ModelWithSingleStringFieldAndDescription) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithSingleStringFieldAndDescription) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	x.StringField, err = d.String()
	if err != nil {
		return err
	}

	return nil
}

type ModelWithSingleInt32Field struct {
	Int32Field int32
}

func NewModelWithSingleInt32Field() *ModelWithSingleInt32Field {
	return &ModelWithSingleInt32Field{

		Int32Field: 32,
	}
}

func (x *ModelWithSingleInt32Field) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Int32(x.Int32Field)

	}
}

func (x *ModelWithSingleInt32Field) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithSingleInt32Field) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return err
	}

	return nil
}

// ModelWithSingleInt32FieldAndDescription: Test Description
type ModelWithSingleInt32FieldAndDescription struct {
	Int32Field int32
}

func NewModelWithSingleInt32FieldAndDescription() *ModelWithSingleInt32FieldAndDescription {
	return &ModelWithSingleInt32FieldAndDescription{

		Int32Field: 32,
	}
}

func (x *ModelWithSingleInt32FieldAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Int32(x.Int32Field)

	}
}

func (x *ModelWithSingleInt32FieldAndDescription) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithSingleInt32FieldAndDescription) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return err
	}

	return nil
}

type ModelWithMultipleFields struct {
	StringField string

	Int32Field int32
}

func NewModelWithMultipleFields() *ModelWithMultipleFields {
	return &ModelWithMultipleFields{

		StringField: "DefaultValue",

		Int32Field: 32,
	}
}

func (x *ModelWithMultipleFields) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.StringField)

		e.Int32(x.Int32Field)

	}
}

func (x *ModelWithMultipleFields) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithMultipleFields) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	x.StringField, err = d.String()
	if err != nil {
		return err
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return err
	}

	return nil
}

// ModelWithMultipleFieldsAndDescription: Test Description
type ModelWithMultipleFieldsAndDescription struct {
	StringField string

	Int32Field int32
}

func NewModelWithMultipleFieldsAndDescription() *ModelWithMultipleFieldsAndDescription {
	return &ModelWithMultipleFieldsAndDescription{

		StringField: "DefaultValue",

		Int32Field: 32,
	}
}

func (x *ModelWithMultipleFieldsAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.StringField)

		e.Int32(x.Int32Field)

	}
}

func (x *ModelWithMultipleFieldsAndDescription) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithMultipleFieldsAndDescription) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	x.StringField, err = d.String()
	if err != nil {
		return err
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return err
	}

	return nil
}

type ModelWithEnum struct {
	EnumField GenericEnum
}

func NewModelWithEnum() *ModelWithEnum {
	return &ModelWithEnum{

		EnumField: GenericEnumDefaultValue,
	}
}

func (x *ModelWithEnum) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Uint32(uint32(x.EnumField))

	}
}

func (x *ModelWithEnum) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithEnum) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return err
	}
	x.EnumField = result

	return nil
}

// ModelWithEnumAndDescription: Test Description
type ModelWithEnumAndDescription struct {
	EnumField GenericEnum
}

func NewModelWithEnumAndDescription() *ModelWithEnumAndDescription {
	return &ModelWithEnumAndDescription{

		EnumField: GenericEnumDefaultValue,
	}
}

func (x *ModelWithEnumAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Uint32(uint32(x.EnumField))

	}
}

func (x *ModelWithEnumAndDescription) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithEnumAndDescription) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return err
	}
	x.EnumField = result

	return nil
}

type ModelWithEnumAccessor struct {
	enumField GenericEnum
}

func NewModelWithEnumAccessor() *ModelWithEnumAccessor {
	return &ModelWithEnumAccessor{

		enumField: GenericEnumDefaultValue,
	}
}

func (x *ModelWithEnumAccessor) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Uint32(uint32(x.enumField))

	}
}

func (x *ModelWithEnumAccessor) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithEnumAccessor) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return err
	}
	x.enumField = result

	return nil
}

func (x *ModelWithEnumAccessor) GetEnumField() (GenericEnum, error) {
	return x.enumField, nil
}

func (x *ModelWithEnumAccessor) SetEnumField(v GenericEnum) error {
	x.enumField = v
	return nil
}

// ModelWithEnumAccessorAndDescription: Test Description
type ModelWithEnumAccessorAndDescription struct {
	enumField GenericEnum
}

func NewModelWithEnumAccessorAndDescription() *ModelWithEnumAccessorAndDescription {
	return &ModelWithEnumAccessorAndDescription{

		enumField: GenericEnumDefaultValue,
	}
}

func (x *ModelWithEnumAccessorAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.Uint32(uint32(x.enumField))

	}
}

func (x *ModelWithEnumAccessorAndDescription) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithEnumAccessorAndDescription) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return err
	}
	x.enumField = result

	return nil
}

func (x *ModelWithEnumAccessorAndDescription) GetEnumField() (GenericEnum, error) {
	return x.enumField, nil
}

func (x *ModelWithEnumAccessorAndDescription) SetEnumField(v GenericEnum) error {
	x.enumField = v
	return nil
}

type ModelWithMultipleFieldsAccessor struct {
	stringField string

	int32Field int32
}

func NewModelWithMultipleFieldsAccessor() *ModelWithMultipleFieldsAccessor {
	return &ModelWithMultipleFieldsAccessor{

		stringField: "DefaultValue",

		int32Field: 32,
	}
}

func (x *ModelWithMultipleFieldsAccessor) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.stringField)

		e.Int32(x.int32Field)

	}
}

func (x *ModelWithMultipleFieldsAccessor) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithMultipleFieldsAccessor) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	x.stringField, err = d.String()
	if err != nil {
		return err
	}

	x.int32Field, err = d.Int32()
	if err != nil {
		return err
	}

	return nil
}

func (x *ModelWithMultipleFieldsAccessor) GetStringField() (string, error) {
	return x.stringField, nil
}

func (x *ModelWithMultipleFieldsAccessor) SetStringField(v string) error {
	if matched, err := regexp.MatchString(`^[a-zA-Z0-9]*$`, v); err != nil || !matched {
		return fmt.Errorf("value must match ^[a-zA-Z0-9]*$")
	}

	if len(v) > 20 || len(v) < 1 {
		return fmt.Errorf("length must be between 1 and 20")
	}

	v = strings.ToUpper(v)

	x.stringField = v
	return nil
}

func (x *ModelWithMultipleFieldsAccessor) GetInt32Field() (int32, error) {
	return x.int32Field, nil
}

func (x *ModelWithMultipleFieldsAccessor) SetInt32Field(v int32) error {
	if v > 100 || v < 0 {
		return fmt.Errorf("value must be between 0 and 100")
	}

	x.int32Field = v
	return nil
}

// ModelWithMultipleFieldsAccessorAndDescription: Test Description
type ModelWithMultipleFieldsAccessorAndDescription struct {
	stringField string

	int32Field int32
}

func NewModelWithMultipleFieldsAccessorAndDescription() *ModelWithMultipleFieldsAccessorAndDescription {
	return &ModelWithMultipleFieldsAccessorAndDescription{

		stringField: "DefaultValue",

		int32Field: 32,
	}
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		e.String(x.stringField)

		e.Int32(x.int32Field)

	}
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	x.stringField, err = d.String()
	if err != nil {
		return err
	}

	x.int32Field, err = d.Int32()
	if err != nil {
		return err
	}

	return nil
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) GetStringField() (string, error) {
	return x.stringField, nil
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) SetStringField(v string) error {

	x.stringField = v
	return nil
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) GetInt32Field() (int32, error) {
	return x.int32Field, nil
}

func (x *ModelWithMultipleFieldsAccessorAndDescription) SetInt32Field(v int32) error {

	x.int32Field = v
	return nil
}

type ModelWithEmbeddedModels struct {
	EmbeddedEmptyModel *EmptyModel

	EmbeddedModelArrayWithMultipleFieldsAccessor []*ModelWithMultipleFieldsAccessor
}

func NewModelWithEmbeddedModels() *ModelWithEmbeddedModels {
	return &ModelWithEmbeddedModels{

		EmbeddedEmptyModel: NewEmptyModel(),

		EmbeddedModelArrayWithMultipleFieldsAccessor: make([]*ModelWithMultipleFieldsAccessor, 0, 64),
	}
}

func (x *ModelWithEmbeddedModels) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.EmbeddedEmptyModel.Encode(b)

		e.Slice(uint32(len(x.EmbeddedModelArrayWithMultipleFieldsAccessor)), polyglot.AnyKind)
		for _, a := range x.EmbeddedModelArrayWithMultipleFieldsAccessor {
			a.Encode(b)
		}

	}
}

func (x *ModelWithEmbeddedModels) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithEmbeddedModels) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	if x.EmbeddedEmptyModel == nil {
		x.EmbeddedEmptyModel = NewEmptyModel()
	}
	err = x.EmbeddedEmptyModel._decode(d)
	if err != nil {
		return err
	}

	sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.EmbeddedModelArrayWithMultipleFieldsAccessor)) != sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor {
		x.EmbeddedModelArrayWithMultipleFieldsAccessor = make([]*ModelWithMultipleFieldsAccessor, sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor)
	}
	for i := uint32(0); i < sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor; i++ {
		x.EmbeddedModelArrayWithMultipleFieldsAccessor[i] = NewModelWithMultipleFieldsAccessor()
		err = x.EmbeddedModelArrayWithMultipleFieldsAccessor[i]._decode(d)
		if err != nil {
			return err
		}
	}

	return nil
}

// ModelWithEmbeddedModelsAndDescription: Test Description
type ModelWithEmbeddedModelsAndDescription struct {
	EmbeddedEmptyModel *EmptyModel

	EmbeddedModelArrayWithMultipleFieldsAccessor []*ModelWithMultipleFieldsAccessor
}

func NewModelWithEmbeddedModelsAndDescription() *ModelWithEmbeddedModelsAndDescription {
	return &ModelWithEmbeddedModelsAndDescription{

		EmbeddedEmptyModel: NewEmptyModel(),

		EmbeddedModelArrayWithMultipleFieldsAccessor: make([]*ModelWithMultipleFieldsAccessor, 0, 0),
	}
}

func (x *ModelWithEmbeddedModelsAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.EmbeddedEmptyModel.Encode(b)

		e.Slice(uint32(len(x.EmbeddedModelArrayWithMultipleFieldsAccessor)), polyglot.AnyKind)
		for _, a := range x.EmbeddedModelArrayWithMultipleFieldsAccessor {
			a.Encode(b)
		}

	}
}

func (x *ModelWithEmbeddedModelsAndDescription) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithEmbeddedModelsAndDescription) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	if x.EmbeddedEmptyModel == nil {
		x.EmbeddedEmptyModel = NewEmptyModel()
	}
	err = x.EmbeddedEmptyModel._decode(d)
	if err != nil {
		return err
	}

	sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.EmbeddedModelArrayWithMultipleFieldsAccessor)) != sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor {
		x.EmbeddedModelArrayWithMultipleFieldsAccessor = make([]*ModelWithMultipleFieldsAccessor, sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor)
	}
	for i := uint32(0); i < sliceSizeEmbeddedModelArrayWithMultipleFieldsAccessor; i++ {
		x.EmbeddedModelArrayWithMultipleFieldsAccessor[i] = NewModelWithMultipleFieldsAccessor()
		err = x.EmbeddedModelArrayWithMultipleFieldsAccessor[i]._decode(d)
		if err != nil {
			return err
		}
	}

	return nil
}

type ModelWithEmbeddedModelsAccessor struct {
	embeddedEmptyModel *EmptyModel

	embeddedModelArrayWithMultipleFieldsAccessor []*ModelWithMultipleFieldsAccessor
}

func NewModelWithEmbeddedModelsAccessor() *ModelWithEmbeddedModelsAccessor {
	return &ModelWithEmbeddedModelsAccessor{

		embeddedEmptyModel: NewEmptyModel(),

		embeddedModelArrayWithMultipleFieldsAccessor: make([]*ModelWithMultipleFieldsAccessor, 0),
	}
}

func (x *ModelWithEmbeddedModelsAccessor) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.embeddedEmptyModel.Encode(b)

		e.Slice(uint32(len(x.embeddedModelArrayWithMultipleFieldsAccessor)), polyglot.AnyKind)
		for _, a := range x.embeddedModelArrayWithMultipleFieldsAccessor {
			a.Encode(b)
		}

	}
}

func (x *ModelWithEmbeddedModelsAccessor) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithEmbeddedModelsAccessor) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	if x.embeddedEmptyModel == nil {
		x.embeddedEmptyModel = NewEmptyModel()
	}
	err = x.embeddedEmptyModel._decode(d)
	if err != nil {
		return err
	}

	sliceSizeembeddedModelArrayWithMultipleFieldsAccessor, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.embeddedModelArrayWithMultipleFieldsAccessor)) != sliceSizeembeddedModelArrayWithMultipleFieldsAccessor {
		x.embeddedModelArrayWithMultipleFieldsAccessor = make([]*ModelWithMultipleFieldsAccessor, sliceSizeembeddedModelArrayWithMultipleFieldsAccessor)
	}
	for i := uint32(0); i < sliceSizeembeddedModelArrayWithMultipleFieldsAccessor; i++ {
		x.embeddedModelArrayWithMultipleFieldsAccessor[i] = NewModelWithMultipleFieldsAccessor()
		err = x.embeddedModelArrayWithMultipleFieldsAccessor[i]._decode(d)
		if err != nil {
			return err
		}
	}

	return nil
}

func (x *ModelWithEmbeddedModelsAccessor) GetEmbeddedEmptyModel() (*EmptyModel, error) {
	return x.embeddedEmptyModel, nil
}

func (x *ModelWithEmbeddedModelsAccessor) SetEmbeddedEmptyModel(v *EmptyModel) error {
	x.embeddedEmptyModel = v
	return nil
}

func (x *ModelWithEmbeddedModelsAccessor) GetEmbeddedModelArrayWithMultipleFieldsAccessor() ([]*ModelWithMultipleFieldsAccessor, error) {
	return x.embeddedModelArrayWithMultipleFieldsAccessor, nil
}

func (x *ModelWithEmbeddedModelsAccessor) SetEmbeddedModelArrayWithMultipleFieldsAccessor(v []*ModelWithMultipleFieldsAccessor) error {
	x.embeddedModelArrayWithMultipleFieldsAccessor = v
	return nil
}

// ModelWithEmbeddedModelsAccessorAndDescription: Test Description
type ModelWithEmbeddedModelsAccessorAndDescription struct {
	embeddedEmptyModel *EmptyModel

	embeddedModelArrayWithMultipleFieldsAccessor []*ModelWithMultipleFieldsAccessor
}

func NewModelWithEmbeddedModelsAccessorAndDescription() *ModelWithEmbeddedModelsAccessorAndDescription {
	return &ModelWithEmbeddedModelsAccessorAndDescription{

		embeddedEmptyModel: NewEmptyModel(),

		embeddedModelArrayWithMultipleFieldsAccessor: make([]*ModelWithMultipleFieldsAccessor, 0),
	}
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.embeddedEmptyModel.Encode(b)

		e.Slice(uint32(len(x.embeddedModelArrayWithMultipleFieldsAccessor)), polyglot.AnyKind)
		for _, a := range x.embeddedModelArrayWithMultipleFieldsAccessor {
			a.Encode(b)
		}

	}
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	if x.embeddedEmptyModel == nil {
		x.embeddedEmptyModel = NewEmptyModel()
	}
	err = x.embeddedEmptyModel._decode(d)
	if err != nil {
		return err
	}

	sliceSizeembeddedModelArrayWithMultipleFieldsAccessor, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.embeddedModelArrayWithMultipleFieldsAccessor)) != sliceSizeembeddedModelArrayWithMultipleFieldsAccessor {
		x.embeddedModelArrayWithMultipleFieldsAccessor = make([]*ModelWithMultipleFieldsAccessor, sliceSizeembeddedModelArrayWithMultipleFieldsAccessor)
	}
	for i := uint32(0); i < sliceSizeembeddedModelArrayWithMultipleFieldsAccessor; i++ {
		x.embeddedModelArrayWithMultipleFieldsAccessor[i] = NewModelWithMultipleFieldsAccessor()
		err = x.embeddedModelArrayWithMultipleFieldsAccessor[i]._decode(d)
		if err != nil {
			return err
		}
	}

	return nil
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) GetEmbeddedEmptyModel() (*EmptyModel, error) {
	return x.embeddedEmptyModel, nil
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) SetEmbeddedEmptyModel(v *EmptyModel) error {
	x.embeddedEmptyModel = v
	return nil
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) GetEmbeddedModelArrayWithMultipleFieldsAccessor() ([]*ModelWithMultipleFieldsAccessor, error) {
	return x.embeddedModelArrayWithMultipleFieldsAccessor, nil
}

func (x *ModelWithEmbeddedModelsAccessorAndDescription) SetEmbeddedModelArrayWithMultipleFieldsAccessor(v []*ModelWithMultipleFieldsAccessor) error {
	x.embeddedModelArrayWithMultipleFieldsAccessor = v
	return nil
}

type ModelWithAllFieldTypes struct {
	ModelField *EmptyModel

	ModelArrayField []*EmptyModel

	ModelMapField map[*EmptyModel]string

	ModelMapFieldEmbedded map[*EmptyModel]*EmptyModel

	StringField string

	StringArrayField []string

	StringMapField map[string]string

	StringMapFieldEmbedded map[string]*EmptyModel

	Int32Field int32

	Int32ArrayField []int32

	Int32MapField map[int32]int32

	Int32MapFieldEmbedded map[int32]*EmptyModel

	Int64Field int64

	Int64ArrayField []int64

	Int64MapField map[int64]int64

	Int64MapFieldEmbedded map[int64]*EmptyModel

	Uint32Field uint32

	Uint32ArrayField []uint32

	Uint32MapField map[uint32]uint32

	Uint32MapFieldEmbedded map[uint32]*EmptyModel

	Uint64Field uint64

	Uint64ArrayField []uint64

	Uint64MapField map[uint64]uint64

	Uint64MapFieldEmbedded map[uint64]*EmptyModel

	Float32Field float32

	Float32ArrayField []float32

	Float32MapField map[float32]float32

	Float32MapFieldEmbedded map[float32]*EmptyModel

	Float64Field float64

	Float64ArrayField []float64

	Float64MapField map[float64]float64

	Float64MapFieldEmbedded map[float64]*EmptyModel

	EnumField GenericEnum

	EnumArrayField []GenericEnum

	EnumMapField map[GenericEnum]string

	EnumMapFieldEmbedded map[GenericEnum]*EmptyModel

	BytesField []byte

	BytesArrayField [][]byte

	BoolField bool

	BoolArrayField []bool
}

func NewModelWithAllFieldTypes() *ModelWithAllFieldTypes {
	return &ModelWithAllFieldTypes{

		ModelField: NewEmptyModel(),

		ModelArrayField: make([]*EmptyModel, 0, 0),

		ModelMapField: make(map[*EmptyModel]string),

		ModelMapFieldEmbedded: make(map[*EmptyModel]*EmptyModel),

		StringField: "DefaultValue",

		StringArrayField: make([]string, 0, 0),

		StringMapField: make(map[string]string),

		StringMapFieldEmbedded: make(map[string]*EmptyModel),

		Int32Field: 32,

		Int32ArrayField: make([]int32, 0, 0),

		Int32MapField: make(map[int32]int32),

		Int32MapFieldEmbedded: make(map[int32]*EmptyModel),

		Int64Field: 64,

		Int64ArrayField: make([]int64, 0, 0),

		Int64MapField: make(map[int64]int64),

		Int64MapFieldEmbedded: make(map[int64]*EmptyModel),

		Uint32Field: 32,

		Uint32ArrayField: make([]uint32, 0, 0),

		Uint32MapField: make(map[uint32]uint32),

		Uint32MapFieldEmbedded: make(map[uint32]*EmptyModel),

		Uint64Field: 64,

		Uint64ArrayField: make([]uint64, 0, 0),

		Uint64MapField: make(map[uint64]uint64),

		Uint64MapFieldEmbedded: make(map[uint64]*EmptyModel),

		Float32Field: 32.32,

		Float32ArrayField: make([]float32, 0, 0),

		Float32MapField: make(map[float32]float32),

		Float32MapFieldEmbedded: make(map[float32]*EmptyModel),

		Float64Field: 64.64,

		Float64ArrayField: make([]float64, 0, 0),

		Float64MapField: make(map[float64]float64),

		Float64MapFieldEmbedded: make(map[float64]*EmptyModel),

		EnumField: GenericEnumDefaultValue,

		EnumArrayField: make([]GenericEnum, 0, 0),

		EnumMapField: make(map[GenericEnum]string),

		EnumMapFieldEmbedded: make(map[GenericEnum]*EmptyModel),

		BytesField: make([]byte, 0),

		BytesArrayField: make([][]byte, 0, 0),

		BoolField: true,

		BoolArrayField: make([]bool, 0, 0),
	}
}

func (x *ModelWithAllFieldTypes) Encode(b *polyglot.Buffer) {
	e := polyglot.Encoder(b)
	if x == nil {
		e.Nil()
	} else {

		x.ModelField.Encode(b)

		e.Slice(uint32(len(x.ModelArrayField)), polyglot.AnyKind)
		for _, a := range x.ModelArrayField {
			a.Encode(b)
		}

		e.Map(uint32(len(x.ModelMapField)), polyglot.AnyKind, polyglot.StringKind)
		for k, v := range x.ModelMapField {
			k.Encode(b)
			e.String(v)
		}

		e.Map(uint32(len(x.ModelMapFieldEmbedded)), polyglot.AnyKind, polyglot.AnyKind)
		for k, v := range x.ModelMapFieldEmbedded {
			k.Encode(b)
			v.Encode(b)
		}

		e.String(x.StringField)

		e.Slice(uint32(len(x.StringArrayField)), polyglot.StringKind)
		for _, a := range x.StringArrayField {
			e.String(a)
		}

		e.Map(uint32(len(x.StringMapField)), polyglot.StringKind, polyglot.StringKind)
		for k, v := range x.StringMapField {
			e.String(k)
			e.String(v)
		}

		e.Map(uint32(len(x.StringMapFieldEmbedded)), polyglot.StringKind, polyglot.AnyKind)
		for k, v := range x.StringMapFieldEmbedded {
			e.String(k)
			v.Encode(b)
		}

		e.Int32(x.Int32Field)

		e.Slice(uint32(len(x.Int32ArrayField)), polyglot.Int32Kind)
		for _, a := range x.Int32ArrayField {
			e.Int32(a)
		}

		e.Map(uint32(len(x.Int32MapField)), polyglot.Int32Kind, polyglot.Int32Kind)
		for k, v := range x.Int32MapField {
			e.Int32(k)
			e.Int32(v)
		}

		e.Map(uint32(len(x.Int32MapFieldEmbedded)), polyglot.Int32Kind, polyglot.AnyKind)
		for k, v := range x.Int32MapFieldEmbedded {
			e.Int32(k)
			v.Encode(b)
		}

		e.Int64(x.Int64Field)

		e.Slice(uint32(len(x.Int64ArrayField)), polyglot.Int64Kind)
		for _, a := range x.Int64ArrayField {
			e.Int64(a)
		}

		e.Map(uint32(len(x.Int64MapField)), polyglot.Int64Kind, polyglot.Int64Kind)
		for k, v := range x.Int64MapField {
			e.Int64(k)
			e.Int64(v)
		}

		e.Map(uint32(len(x.Int64MapFieldEmbedded)), polyglot.Int64Kind, polyglot.AnyKind)
		for k, v := range x.Int64MapFieldEmbedded {
			e.Int64(k)
			v.Encode(b)
		}

		e.Uint32(x.Uint32Field)

		e.Slice(uint32(len(x.Uint32ArrayField)), polyglot.Uint32Kind)
		for _, a := range x.Uint32ArrayField {
			e.Uint32(a)
		}

		e.Map(uint32(len(x.Uint32MapField)), polyglot.Uint32Kind, polyglot.Uint32Kind)
		for k, v := range x.Uint32MapField {
			e.Uint32(k)
			e.Uint32(v)
		}

		e.Map(uint32(len(x.Uint32MapFieldEmbedded)), polyglot.Uint32Kind, polyglot.AnyKind)
		for k, v := range x.Uint32MapFieldEmbedded {
			e.Uint32(k)
			v.Encode(b)
		}

		e.Uint64(x.Uint64Field)

		e.Slice(uint32(len(x.Uint64ArrayField)), polyglot.Uint64Kind)
		for _, a := range x.Uint64ArrayField {
			e.Uint64(a)
		}

		e.Map(uint32(len(x.Uint64MapField)), polyglot.Uint64Kind, polyglot.Uint64Kind)
		for k, v := range x.Uint64MapField {
			e.Uint64(k)
			e.Uint64(v)
		}

		e.Map(uint32(len(x.Uint64MapFieldEmbedded)), polyglot.Uint64Kind, polyglot.AnyKind)
		for k, v := range x.Uint64MapFieldEmbedded {
			e.Uint64(k)
			v.Encode(b)
		}

		e.Float32(x.Float32Field)

		e.Slice(uint32(len(x.Float32ArrayField)), polyglot.Float32Kind)
		for _, a := range x.Float32ArrayField {
			e.Float32(a)
		}

		e.Map(uint32(len(x.Float32MapField)), polyglot.Float32Kind, polyglot.Float32Kind)
		for k, v := range x.Float32MapField {
			e.Float32(k)
			e.Float32(v)
		}

		e.Map(uint32(len(x.Float32MapFieldEmbedded)), polyglot.Float32Kind, polyglot.AnyKind)
		for k, v := range x.Float32MapFieldEmbedded {
			e.Float32(k)
			v.Encode(b)
		}

		e.Float64(x.Float64Field)

		e.Slice(uint32(len(x.Float64ArrayField)), polyglot.Float64Kind)
		for _, a := range x.Float64ArrayField {
			e.Float64(a)
		}

		e.Map(uint32(len(x.Float64MapField)), polyglot.Float64Kind, polyglot.Float64Kind)
		for k, v := range x.Float64MapField {
			e.Float64(k)
			e.Float64(v)
		}

		e.Map(uint32(len(x.Float64MapFieldEmbedded)), polyglot.Float64Kind, polyglot.AnyKind)
		for k, v := range x.Float64MapFieldEmbedded {
			e.Float64(k)
			v.Encode(b)
		}

		e.Uint32(uint32(x.EnumField))

		e.Slice(uint32(len(x.EnumArrayField)), polyglot.Uint32Kind)
		for _, a := range x.EnumArrayField {
			e.Uint32(uint32(a))
		}

		e.Map(uint32(len(x.EnumMapField)), polyglot.Uint32Kind, polyglot.StringKind)
		for k, v := range x.EnumMapField {
			e.Uint32(uint32(k))
			e.String(v)
		}

		e.Map(uint32(len(x.EnumMapFieldEmbedded)), polyglot.Uint32Kind, polyglot.AnyKind)
		for k, v := range x.EnumMapFieldEmbedded {
			e.Uint32(uint32(k))
			v.Encode(b)
		}

		e.Bytes(x.BytesField)

		e.Slice(uint32(len(x.BytesArrayField)), polyglot.BytesKind)
		for _, a := range x.BytesArrayField {
			e.Bytes(a)
		}

		e.Bool(x.BoolField)

		e.Slice(uint32(len(x.BoolArrayField)), polyglot.BoolKind)
		for _, a := range x.BoolArrayField {
			e.Bool(a)
		}

	}
}

func (x *ModelWithAllFieldTypes) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x._decode(d)
}

func (x *ModelWithAllFieldTypes) _decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	err, _ := d.Error()
	if err != nil {
		return err
	}

	if x.ModelField == nil {
		x.ModelField = NewEmptyModel()
	}
	err = x.ModelField._decode(d)
	if err != nil {
		return err
	}

	sliceSizeModelArrayField, err := d.Slice(polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.ModelArrayField)) != sliceSizeModelArrayField {
		x.ModelArrayField = make([]*EmptyModel, sliceSizeModelArrayField)
	}
	for i := uint32(0); i < sliceSizeModelArrayField; i++ {
		x.ModelArrayField[i] = NewEmptyModel()
		err = x.ModelArrayField[i]._decode(d)
		if err != nil {
			return err
		}
	}

	mapSizeModelMapField, err := d.Map(polyglot.AnyKind, polyglot.StringKind)
	if err != nil {
		return err
	}
	if uint32(len(x.ModelMapField)) != mapSizeModelMapField {
		x.ModelMapField = make(map[*EmptyModel]string, mapSizeModelMapField)
	}
	for i := uint32(0); i < mapSizeModelMapField; i++ {

		k := NewEmptyModel()
		err = k._decode(d)
		if err != nil {
			return err
		}
		x.ModelMapField[k], err = d.String()
		if err != nil {
			return err
		}
	}

	mapSizeModelMapFieldEmbedded, err := d.Map(polyglot.AnyKind, polyglot.AnyKind)
	if err != nil {
		return err
	}
	if uint32(len(x.ModelMapFieldEmbedded)) != mapSizeModelMapFieldEmbedded {
		x.ModelMapFieldEmbedded = make(map[*EmptyModel]*EmptyModel, mapSizeModelMapFieldEmbedded)
	}
	for i := uint32(0); i < mapSizeModelMapFieldEmbedded; i++ {
		k := NewEmptyModel()
		err = k._decode(d)
		if err != nil {
			return err
		}
		v := NewEmptyModel()
		err = v._decode(d)
		if err != nil {
			return err
		}
		x.ModelMapFieldEmbedded[k] = v
	}

	x.StringField, err = d.String()
	if err != nil {
		return err
	}

	sliceSizeStringArrayField, err := d.Slice(polyglot.StringKind)
	if err != nil {
		return err
	}

	if uint32(len(x.StringArrayField)) != sliceSizeStringArrayField {
		x.StringArrayField = make([]string, sliceSizeStringArrayField)
	}

	for i := uint32(0); i < sliceSizeStringArrayField; i++ {
		x.StringArrayField[i], err = d.String()
		if err != nil {
			return err
		}
	}

	mapSizeStringMapField, err := d.Map(polyglot.StringKind, polyglot.StringKind)
	if err != nil {
		return err
	}

	if uint32(len(x.StringMapField)) != mapSizeStringMapField {
		x.StringMapField = make(map[string]string, mapSizeStringMapField)
	}

	for i := uint32(0); i < mapSizeStringMapField; i++ {
		k, err := d.String()
		if err != nil {
			return err
		}
		x.StringMapField[k], err = d.String()
		if err != nil {
			return err
		}
	}

	mapSizeStringMapFieldEmbedded, err := d.Map(polyglot.StringKind, polyglot.AnyKind)
	if err != nil {
		return err
	}

	if uint32(len(x.StringMapFieldEmbedded)) != mapSizeStringMapFieldEmbedded {
		x.StringMapFieldEmbedded = make(map[string]*EmptyModel, mapSizeStringMapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeStringMapFieldEmbedded; i++ {
		k, err := d.String()
		if err != nil {
			return err
		}
		v := NewEmptyModel()
		err = v._decode(d)
		if err != nil {
			return err
		}
		x.StringMapFieldEmbedded[k] = v
	}

	x.Int32Field, err = d.Int32()
	if err != nil {
		return err
	}

	sliceSizeInt32ArrayField, err := d.Slice(polyglot.Int32Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Int32ArrayField)) != sliceSizeInt32ArrayField {
		x.Int32ArrayField = make([]int32, sliceSizeInt32ArrayField)
	}

	for i := uint32(0); i < sliceSizeInt32ArrayField; i++ {
		x.Int32ArrayField[i], err = d.Int32()
		if err != nil {
			return err
		}
	}

	mapSizeInt32MapField, err := d.Map(polyglot.Int32Kind, polyglot.Int32Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Int32MapField)) != mapSizeInt32MapField {
		x.Int32MapField = make(map[int32]int32, mapSizeInt32MapField)
	}

	for i := uint32(0); i < mapSizeInt32MapField; i++ {
		k, err := d.Int32()
		if err != nil {
			return err
		}
		x.Int32MapField[k], err = d.Int32()
		if err != nil {
			return err
		}
	}

	mapSizeInt32MapFieldEmbedded, err := d.Map(polyglot.Int32Kind, polyglot.AnyKind)
	if err != nil {
		return err
	}

	if uint32(len(x.Int32MapFieldEmbedded)) != mapSizeInt32MapFieldEmbedded {
		x.Int32MapFieldEmbedded = make(map[int32]*EmptyModel, mapSizeInt32MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeInt32MapFieldEmbedded; i++ {
		k, err := d.Int32()
		if err != nil {
			return err
		}
		v := NewEmptyModel()
		err = v._decode(d)
		if err != nil {
			return err
		}
		x.Int32MapFieldEmbedded[k] = v
	}

	x.Int64Field, err = d.Int64()
	if err != nil {
		return err
	}

	sliceSizeInt64ArrayField, err := d.Slice(polyglot.Int64Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Int64ArrayField)) != sliceSizeInt64ArrayField {
		x.Int64ArrayField = make([]int64, sliceSizeInt64ArrayField)
	}

	for i := uint32(0); i < sliceSizeInt64ArrayField; i++ {
		x.Int64ArrayField[i], err = d.Int64()
		if err != nil {
			return err
		}
	}

	mapSizeInt64MapField, err := d.Map(polyglot.Int64Kind, polyglot.Int64Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Int64MapField)) != mapSizeInt64MapField {
		x.Int64MapField = make(map[int64]int64, mapSizeInt64MapField)
	}

	for i := uint32(0); i < mapSizeInt64MapField; i++ {
		k, err := d.Int64()
		if err != nil {
			return err
		}
		x.Int64MapField[k], err = d.Int64()
		if err != nil {
			return err
		}
	}

	mapSizeInt64MapFieldEmbedded, err := d.Map(polyglot.Int64Kind, polyglot.AnyKind)
	if err != nil {
		return err
	}

	if uint32(len(x.Int64MapFieldEmbedded)) != mapSizeInt64MapFieldEmbedded {
		x.Int64MapFieldEmbedded = make(map[int64]*EmptyModel, mapSizeInt64MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeInt64MapFieldEmbedded; i++ {
		k, err := d.Int64()
		if err != nil {
			return err
		}
		v := NewEmptyModel()
		err = v._decode(d)
		if err != nil {
			return err
		}
		x.Int64MapFieldEmbedded[k] = v
	}

	x.Uint32Field, err = d.Uint32()
	if err != nil {
		return err
	}

	sliceSizeUint32ArrayField, err := d.Slice(polyglot.Uint32Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Uint32ArrayField)) != sliceSizeUint32ArrayField {
		x.Uint32ArrayField = make([]uint32, sliceSizeUint32ArrayField)
	}

	for i := uint32(0); i < sliceSizeUint32ArrayField; i++ {
		x.Uint32ArrayField[i], err = d.Uint32()
		if err != nil {
			return err
		}
	}

	mapSizeUint32MapField, err := d.Map(polyglot.Uint32Kind, polyglot.Uint32Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Uint32MapField)) != mapSizeUint32MapField {
		x.Uint32MapField = make(map[uint32]uint32, mapSizeUint32MapField)
	}

	for i := uint32(0); i < mapSizeUint32MapField; i++ {
		k, err := d.Uint32()
		if err != nil {
			return err
		}
		x.Uint32MapField[k], err = d.Uint32()
		if err != nil {
			return err
		}
	}

	mapSizeUint32MapFieldEmbedded, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
	if err != nil {
		return err
	}

	if uint32(len(x.Uint32MapFieldEmbedded)) != mapSizeUint32MapFieldEmbedded {
		x.Uint32MapFieldEmbedded = make(map[uint32]*EmptyModel, mapSizeUint32MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeUint32MapFieldEmbedded; i++ {
		k, err := d.Uint32()
		if err != nil {
			return err
		}
		v := NewEmptyModel()
		err = v._decode(d)
		if err != nil {
			return err
		}
		x.Uint32MapFieldEmbedded[k] = v
	}

	x.Uint64Field, err = d.Uint64()
	if err != nil {
		return err
	}

	sliceSizeUint64ArrayField, err := d.Slice(polyglot.Uint64Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Uint64ArrayField)) != sliceSizeUint64ArrayField {
		x.Uint64ArrayField = make([]uint64, sliceSizeUint64ArrayField)
	}

	for i := uint32(0); i < sliceSizeUint64ArrayField; i++ {
		x.Uint64ArrayField[i], err = d.Uint64()
		if err != nil {
			return err
		}
	}

	mapSizeUint64MapField, err := d.Map(polyglot.Uint64Kind, polyglot.Uint64Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Uint64MapField)) != mapSizeUint64MapField {
		x.Uint64MapField = make(map[uint64]uint64, mapSizeUint64MapField)
	}

	for i := uint32(0); i < mapSizeUint64MapField; i++ {
		k, err := d.Uint64()
		if err != nil {
			return err
		}
		x.Uint64MapField[k], err = d.Uint64()
		if err != nil {
			return err
		}
	}

	mapSizeUint64MapFieldEmbedded, err := d.Map(polyglot.Uint64Kind, polyglot.AnyKind)
	if err != nil {
		return err
	}

	if uint32(len(x.Uint64MapFieldEmbedded)) != mapSizeUint64MapFieldEmbedded {
		x.Uint64MapFieldEmbedded = make(map[uint64]*EmptyModel, mapSizeUint64MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeUint64MapFieldEmbedded; i++ {
		k, err := d.Uint64()
		if err != nil {
			return err
		}
		v := NewEmptyModel()
		err = v._decode(d)
		if err != nil {
			return err
		}
		x.Uint64MapFieldEmbedded[k] = v
	}

	x.Float32Field, err = d.Float32()
	if err != nil {
		return err
	}

	sliceSizeFloat32ArrayField, err := d.Slice(polyglot.Float32Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Float32ArrayField)) != sliceSizeFloat32ArrayField {
		x.Float32ArrayField = make([]float32, sliceSizeFloat32ArrayField)
	}

	for i := uint32(0); i < sliceSizeFloat32ArrayField; i++ {
		x.Float32ArrayField[i], err = d.Float32()
		if err != nil {
			return err
		}
	}

	mapSizeFloat32MapField, err := d.Map(polyglot.Float32Kind, polyglot.Float32Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Float32MapField)) != mapSizeFloat32MapField {
		x.Float32MapField = make(map[float32]float32, mapSizeFloat32MapField)
	}

	for i := uint32(0); i < mapSizeFloat32MapField; i++ {
		k, err := d.Float32()
		if err != nil {
			return err
		}
		x.Float32MapField[k], err = d.Float32()
		if err != nil {
			return err
		}
	}

	mapSizeFloat32MapFieldEmbedded, err := d.Map(polyglot.Float32Kind, polyglot.AnyKind)
	if err != nil {
		return err
	}

	if uint32(len(x.Float32MapFieldEmbedded)) != mapSizeFloat32MapFieldEmbedded {
		x.Float32MapFieldEmbedded = make(map[float32]*EmptyModel, mapSizeFloat32MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeFloat32MapFieldEmbedded; i++ {
		k, err := d.Float32()
		if err != nil {
			return err
		}
		v := NewEmptyModel()
		err = v._decode(d)
		if err != nil {
			return err
		}
		x.Float32MapFieldEmbedded[k] = v
	}

	x.Float64Field, err = d.Float64()
	if err != nil {
		return err
	}

	sliceSizeFloat64ArrayField, err := d.Slice(polyglot.Float64Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Float64ArrayField)) != sliceSizeFloat64ArrayField {
		x.Float64ArrayField = make([]float64, sliceSizeFloat64ArrayField)
	}

	for i := uint32(0); i < sliceSizeFloat64ArrayField; i++ {
		x.Float64ArrayField[i], err = d.Float64()
		if err != nil {
			return err
		}
	}

	mapSizeFloat64MapField, err := d.Map(polyglot.Float64Kind, polyglot.Float64Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.Float64MapField)) != mapSizeFloat64MapField {
		x.Float64MapField = make(map[float64]float64, mapSizeFloat64MapField)
	}

	for i := uint32(0); i < mapSizeFloat64MapField; i++ {
		k, err := d.Float64()
		if err != nil {
			return err
		}
		x.Float64MapField[k], err = d.Float64()
		if err != nil {
			return err
		}
	}

	mapSizeFloat64MapFieldEmbedded, err := d.Map(polyglot.Float64Kind, polyglot.AnyKind)
	if err != nil {
		return err
	}

	if uint32(len(x.Float64MapFieldEmbedded)) != mapSizeFloat64MapFieldEmbedded {
		x.Float64MapFieldEmbedded = make(map[float64]*EmptyModel, mapSizeFloat64MapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeFloat64MapFieldEmbedded; i++ {
		k, err := d.Float64()
		if err != nil {
			return err
		}
		v := NewEmptyModel()
		err = v._decode(d)
		if err != nil {
			return err
		}
		x.Float64MapFieldEmbedded[k] = v
	}

	result, err := decodeGenericEnum(d)
	if err != nil {
		return err
	}
	x.EnumField = result

	sliceSizeEnumArrayField, err := d.Slice(polyglot.Uint32Kind)
	if err != nil {
		return err
	}

	if uint32(len(x.EnumArrayField)) != sliceSizeEnumArrayField {
		x.EnumArrayField = make([]GenericEnum, sliceSizeEnumArrayField)
	}

	for i := uint32(0); i < sliceSizeEnumArrayField; i++ {
		val, err := decodeGenericEnum(d)
		if err != nil {
			return err
		}
		x.EnumArrayField[i] = val
	}

	mapSizeEnumMapField, err := d.Map(polyglot.Uint32Kind, polyglot.StringKind)
	if err != nil {
		return err
	}

	if uint32(len(x.EnumMapField)) != mapSizeEnumMapField {
		x.EnumMapField = make(map[GenericEnum]string, mapSizeEnumMapField)
	}

	for i := uint32(0); i < mapSizeEnumMapField; i++ {
		k, err := decodeGenericEnum(d)
		if err != nil {
			return err
		}
		x.EnumMapField[k], err = d.String()
		if err != nil {
			return err
		}
	}

	mapSizeEnumMapFieldEmbedded, err := d.Map(polyglot.Uint32Kind, polyglot.AnyKind)
	if err != nil {
		return err
	}

	if uint32(len(x.EnumMapFieldEmbedded)) != mapSizeEnumMapFieldEmbedded {
		x.EnumMapFieldEmbedded = make(map[GenericEnum]*EmptyModel, mapSizeEnumMapFieldEmbedded)
	}

	for i := uint32(0); i < mapSizeEnumMapFieldEmbedded; i++ {
		k, err := decodeGenericEnum(d)
		if err != nil {
			return err
		}
		v := NewEmptyModel()
		err = v._decode(d)
		if err != nil {
			return err
		}
		x.EnumMapFieldEmbedded[k] = v
	}

	x.BytesField, err = d.Bytes(nil)
	if err != nil {
		return err
	}

	sliceSizeBytesArrayField, err := d.Slice(polyglot.BytesKind)
	if err != nil {
		return err
	}

	if uint32(len(x.BytesArrayField)) != sliceSizeBytesArrayField {
		x.BytesArrayField = make([][]byte, sliceSizeBytesArrayField)
	}

	for i := uint32(0); i < sliceSizeBytesArrayField; i++ {
		x.BytesArrayField[i], err = d.Bytes(nil)
		if err != nil {
			return err
		}
	}

	x.BoolField, err = d.Bool()
	if err != nil {
		return err
	}

	sliceSizeBoolArrayField, err := d.Slice(polyglot.BoolKind)
	if err != nil {
		return err
	}

	if uint32(len(x.BoolArrayField)) != sliceSizeBoolArrayField {
		x.BoolArrayField = make([]bool, sliceSizeBoolArrayField)
	}

	for i := uint32(0); i < sliceSizeBoolArrayField; i++ {
		x.BoolArrayField[i], err = d.Bool()
		if err != nil {
			return err
		}
	}

	return nil
}
